\chapter{Implementação}
\label{cap:implementacao}

% Neste capítulo será tratada a implementação do \textit{símbolo de Legendre}, trazendo um conteúdo dividido em três partes: apresentação do sistema de hierarquia de estruturas algébricas, discussão sobre implementações de outros conteúdos externos a este trabalho consideradas fundamentais para realização do objetivo proposto, e por fim as implementações realizadas no presente trabalho.
Neste capítulo será tratada a implementação do \textit{símbolo de Legendre}, trazendo um conteúdo dividido em duas partes: discussão sobre implementações externas relacionadas a este trabalho (consideradas fundamentais para realização do objetivo proposto) e as implementações realizadas no presente trabalho.
        
Vale ressaltar que existem implementações sobre \textit{símbolo de Legendre} fora da biblioteca Mathematical Components. Como exemplo de tais implementações tem-se, na biblioteca Mathlib\footnote{Disponível em: \url{https://github.com/leanprover-community/mathlib4}} do auxiliador de provas \textit{Lean}, tanto a implementação de \textit{símbolo de Legendre} quanto da \textit{Lei de Reciprocidade Quadrática}
(tema este discutido no Apêndice \ref{cap:reciprocidadequadratica}). Há também a implementação de tais conteúdos em \textit{Coq} (sem utilização da biblioteca Mathematical Components) publicada em repositório\footnote{Disponível em: \url{https://github.com/Ekdohibs/coq-proofs/tree/master/Reciprocity}} de Nathanaëlle Courant disponível no GitHub. Ainda assim, a implementação aqui realizada tem contribuição significativa, uma vez que muito do desenvolvimento de provas matemáticas em \textit{Coq} ocorre através do uso da Mathematical Components.

% \section{Hierarquias entre Estruturas Algébricas}

% Ao se utilizar a biblioteca Mathematical Components pela primeira vez o usuário tende a necessitar corriqueiramente da ferramenta de busca de teoremas, lemas e definições. Isto tende acontecer pois em geral o usuário precisa aprendar os nomes (e padrões destes) utilizados na biblioteca e o como são implementados. Como exemplo suponha que queira-se rescrever uma expressão com números naturais utilizando a propriedade de comutatividade: o lema para isto é dado por \lstinline[language = coq]!addnC! e pode ser notado como o lema que se deseja utilizar por sua definição:
% \begin{lstlisting}[language=coq]
%         Lemma addnC : commutative addn.
% \end{lstlisting}
% Agora, supondo que se tenha a mesma situação envolvendo números inteiros. É provável que não seja tão simples para o mesmo usuário encontrar o lema desejado, pois nesse caso, apesar da existência do lema \lstinline[language = coq]!addzC! com definição:
% \begin{lstlisting}[language=coq]
%         Lemma addzC : commutative addz.
% \end{lstlisting}
% pelo fato da notação \lstinline[language = coq]!+! não ser definida para a operação \lstinline[language = coq]!addz! (operação de soma entre inteiros) mas sim para determinadas operações binárias de estruturas semelhantes ao \textit{record} apresentado na Subseção \ref{sub:grupos}, tal lema não irá servir (exceto caso o usuário esteja utilizando a função \lstinline[language = coq]!addz! e não a notação \lstinline[language = coq]!+!).

% Sendo assim, para realizar a manipulação desejada, deve-se utilizar o lema \lstinline[language = coq]!addrC!, qual possui a seguinte definição: 
% \begin{lstlisting}[language=coq]
%         forall s : nmodType, commutative +%R
% \end{lstlisting}
% Note que o lema é definido pra uma estrutura \lstinline[language = coq]!nmodType!; estruturas como essa são muito comuns nos códigos da Mathematical Components, e, conforme apresentado no guia de contribuições da biblioteca\footnote{Disponível em: https://github.com/math-comp/math-comp/blob/master/CONTRIBUTING.md}, pode-se verificar, utilizando a linguagem HB \cite{cohen_et_al:LIPIcs.FSCD.2020.34} para hierarquia de estruturas algébricas, os lemas que caracterizam \lstinline[language = coq]!nmodType!, usando o seguinte comando: 
% \begin{lstlisting}[language=coq]
%         HB.about nmodType.
% \end{lstlisting}
% que irá apresentar uma mensagem contendo, em parte dela, o seguinte conteúdo:
% \begin{lstlisting}[language=coq-error]
%         HB: nmodType is a structure (from "./ssralg.v", line 589)
%         HB: nmodType characterizing operations and axioms are:
%         - add0r
%         - addrC
%         - addrA
%         - add
%         - zero
% \end{lstlisting}
% Verificando as definições dos nomes apresentados nesta mensagem podemos notar que tal estrutura possui uma operação (\lstinline[language = coq]!add!), um elemento neutro à esquerda (\lstinline[language = coq]!zero! e \lstinline[language = coq]!add0r!) e as propriedades de comutatividade e associatividade para tal operação (\lstinline[language = coq]!addrC! e \lstinline[language = coq]!addrA!).
% Usando o mesmo comando (\lstinline[language = coq]!HB.about!) sobre o tipo \lstinline[language = coq]!int!, tem-se como resultado na mensagem apresentada as estruturas com as quais o tipo está ``equipado'', e dentre estas tem-se \lstinline[language = coq]!GRing.Nmodule! (para qual \lstinline[language=coq]!nmodType! é um sinônimo). 

% Tal organização presente na biblioteca, ao ser conhecida pelo usuário, torna mais fácil e organizada a manipulação de diferentes tipos, e é portanto uma informação importante para leitores deste trabalho que desejam futuramente fazer uso da mesma biblioteca. 

% \textcolor{red}{ Ainda da pra mexer nessa subseção, pra citar mais referências apesar de eu não ter precisado tanto por que as informações são meio obvias após algum tempo de uso da biblioteca, acho q é interessante citar pra dar mais segurança ao leitor (e a mim mesmo também)}

% \textcolor{darkgreen}{\textbf{IDEIA}: jogar essa seção para o Capítulo 2.}
% % conforme apresentado em \cite{2023multipleinheritancehazardsdependentlytypedalgebraic}, são utilizadas para 

\section{Implementações Externas de Maior Relevância}
\label{sec:implementacoes}

Dentre os teoremas e lemas utilizados neste trabalho (dos quais a grande maioria são lemas simples da biblioteca Mathematical Components), existem dois que merecem destaque devido a complexidade para a prova dos mesmos. Este empecilho em suas respectivas provas ocorre pela dificuldade em se fazer uma formalização com base nas ideias de prova manual para os mesmos (ambas apresentadas neste trabalho).

O primeiro lema a ser mencionado trata do caso \ref{item:caso3wilson} do Teorema \ref{teorema : wilson} e possui, na biblioteca, o seguinte enunciado:
        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Theorem Wilson p : p > 1 -> prime p = (p %| ((p.-1)`!).+1).
        \end{lstlisting}
É importante notar que a igualdade entre as proposições booleanas \lstinline[language=coq]!p %| ((p.-1)`!).+1! e \lstinline[language=coq]!prime p! equivale a uma bi-implicação caso estas proposições fossem de tipo \lstinline[language=coq]|Prop|. Note que, pela definição de equivalência em módulo $p$, há a seguinte bi-implicação:
% Além disso, vale aqui lembrar da definição de equivalência em módulo $p$, e que portanto:
        \begin{equation}
                p \mid (p-1)! + 1 \Longleftrightarrow (p-1)! \equiv -1 \pmod{p} 
        \end{equation}

Quanto ao segundo item a ser mencionado, este trata do Lema \ref{lema : modp-1fat} provado por Laurent Théry durante o período de realização deste trabalho. A prova deste está disponível em \url{https://github.com/thery/mathcomp-extra/blob/master/euler.v} e tem a seguinte declaração:
        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma fact_sqr_exp a p :
        prime p -> ~~ (p %| a) -> ~~ res_quad p a -> (p.-1`!) = a ^ p.-1./2 %[mod p].
        \end{lstlisting}
onde \lstinline[language=coq]!res_quad! tem a seguinte definição:
        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Definition res_quad p a := has (fun i => i * i == a %[mod p]) (iota 0 p).
        \end{lstlisting}
em que, a função \lstinline[language=coq]!has! recebe um predicado booleano e uma lista, e então retorna \lstinline[language=coq]!true!
se há algum elemento da lista que satisfaz o predicado e \lstinline[language=coq]!false! caso contrário. Já a função \lstinline[language=coq]!iota! recebe dois números naturais $m$ e $n$ e retorna uma lista crescente de todos os naturais de $m$ até $n-1+m$. Sendo assim, a função \lstinline[language=coq]!res_quad! é um método exaustivo para verificar se há um valor $r$ tal que $r^{2} \equiv a \pmod{p}$.

% O lema \coqinline[]{fact_sqr_exp} foi usado por Laurent Théry na prova da seguinte versão do \textit{Critério de Euler} (Lema \ref{teorema:criteriodeeuler}):
%         \begin{lstlisting}[language=coq,frame=single,tabsize=1]
% Lemma euler_criterion a p : 
%         prime p -> ~~ (p %| a) -> 
%         a ^ p.-1./2 = (if res_quad p a then 1 else p.-1) %[mod p].
%         \end{lstlisting}

As dificuldades relacionadas às provas destas declarações em \textit{Coq}, se baseando nas ideias de provais manuais apresentadas neste trabalho, devem-se ao fato de que tais ideias sugerem a reorganização de todos os termos de produtórios com tamanho arbitrário. Tais provas não podem ser evitadas na implementação de \textit{símbolo de Legendre} em \textit{Coq} dado que tratam de conteúdos diretamente relacionados (principalmente ao se considerar o Teorema \ref{teorema:criteriodeeuler}).

Devido a essa dificuldade, que pode vir a aparecer em diversas situações onde tem-se uma ideia de prova semelhante a ser formalizada, as implementações das provas do Teorema \ref{teorema : wilson} e do Lema \ref{lema : modp-1fat}, em \textit{Coq}, são interessantes de serem analisadas. A prova do Lema \ref{lema : modp-1fat} foi realiza por Laurent Théry e o código pode ser divido nas seguintes etapas:

% é de interesse se ter conhecimento de como as provas do Teorema \ref{teorema : wilson} e do Lema \ref{lema : modp-1fat} foram feitas em \textit{Coq}. Para satisfazer tal necessidade será aqui explicada em detalhe (com excessão da maioria dos \textit{subgoals} e outras partes triviais) o conteúdo da prova do Lema \ref{lema : modp-1fat} realizada por Laurent Théry. O código da prova pode-ser divido nas seguintes etapas:

\begin{enumerate}[label=\textbf{\roman*.}]

        % Parte 01:

        \item Inicialmente tem-se o seguinte \textit{goal}:
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
prime p -> ~~ (p %| a) -> ~~ res_quad p a -> (p.-1`!) = a ^ p.-1./2 %[mod p]
                \end{lstlisting}
        Introduz-se então todas as hipóteses e se reescreve $(p-1)!$:
                \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1,name=proof]
move=> pP pNDa aR.
have -> : p.-1`! = \prod_(i in 'F_p | i != 0%R) i.
        (* ... prova do subgoal... *)
                \end{lstlisting}
        Explicando os comandos feitos em linhas específicas têm-se:
        \begin{enumerate}
                \item[\textbf{(1)}] Introdução dos precedentes do \textit{goal} para hipóteses com os nomes \lstinline[language=coq]|pP|, \lstinline[language=coq]|pNDa| e \lstinline[language=coq]|aR| respectivamente.
                
                \item[\textbf{(2)}] Reescrita de $(p-1)!$ como $\prod_{i \in (\mathbb{F}_p - \{0\})} i$ (o que abre um \textit{subgoal}, que é por sua vez trivial).
                
                % \item[\textbf{(3)}] resolução do \textit{subgoal} aberto na linha 2.
        \end{enumerate}

        % Parte 02:

        \item Tendo agora o seguinte \textit{goal}:
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(i in 'F_p | i != 0%R) i  = a ^ p.-1./2  %[mod p]
                \end{lstlisting}
        faz-se então uma série de declarações de variáveis e funções junto à introdução de novas hipóteses:
                \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1,escapechar=@, name=proof]
pose a' : 'F_p := inZp a.                       @ \label{line:4-item2} @
have a'E : a' = a %% p :> nat                   @ \label{line:5-item2} @
        by rewrite /= Fp_cast.                  @ \label{line:6-item2} @
have a'_neq0 : a' != 0%R.                       @ \label{line:7-item2} @
        (*... prova do subgoal...*)             @ \label{line:8-item2} @
rewrite -modnXm -a'E.                                                   @ \label{line:9-item2} @
pose f (i : 'F_p) : 'F_p := (a' / i)%R.                                 @ \label{line:10-item2} @
have f_eq0 : f 0%R = 0%R by rewrite /f GRing.invr0 GRing.mulr0.         @ \label{line:11-item2} @
have fM (i : 'F_p) : i != ord0 -> (f i * i = a')%R.                     @ \label{line:12-item2} @
        (*... prova do subgoal...*)                                     @ \label{line:13-item2} @
have fI (i : 'F_p) : f (f i) = i.                                       @ \label{line:14-item2} @
        (*... prova do subgoal...*)                                     @ \label{line:15-item2} @
have fI_neq0 (i : 'F_p) : i != 0%R -> f i != i.                         @ \label{line:16-item2} @
        (*... prova do subgoal...*)                                     @ \label{line:17-item2} @
have fB : {on [pred i |  i != ord0],  bijective f}.                     @ \label{line:18-item2} @
        (*... prova do subgoal...*)                                     @ \label{line:19-item2} @
pose can (i : 'F_p) :=  if i < (f i) then i else f i.                   @ \label{line:20-item2} @
                \end{lstlisting}
        Explicando os comandos feitos em linhas específicas têm-se:
        \begin{enumerate}
                \item[\textbf{(\ref{line:4-item2})}] Declaração da variável $a' \in \mathbb{F}_p$ que por sua vez depende do valor de $a$.
                
                \item[\textbf{(\ref{line:5-item2})}] Introdução da hipótese \lstinline[language=coq]|a'E| de que $a' = a \bmod{p}$.
                
                \item[\textbf{(\ref{line:7-item2})}] Introdução da hipótese \lstinline[language=coq]|a'_neq0| de que $a' \neq 0$.
                
                \item[\textbf{(\ref{line:9-item2})}] Reescrita (no \textit{goal}) de $a^{\frac{p-1}{2}}$ como $(a')^{\frac{p-1}{2}}$.
                
                \item[\textbf{(\ref{line:10-item2})}] Declaração de uma função $f : \mathbb{F}_p \rightarrow \mathbb{F}_p$ tal que $f(i) = (a') \cdot i^{-1}$ (onde $i^{-1}$ é o inverso de $i$ em $\mathbb{F}_p$ e a notação \lstinline[language=coq]|"x / y"| é definida como \lstinline[language=coq]|x * y^-1|).
                
                \item[\textbf{(\ref{line:11-item2})}] Introdução (e prova na mesma linha a partir do comando \lstinline[language=coq]|by|) da hipótese \lstinline[language=coq]|f_eq0| de que $f(0) = 0$.
                
                \item[\textbf{(\ref{line:12-item2})}] Introdução da hipótese \lstinline[language=coq]|fM| de que $\forall i \in \mathbb{F}_p, (i \neq 0 \rightarrow f(i) \cdot i = a')$;
                
                \item[\textbf{(\ref{line:14-item2})}] Introdução da hipótese \lstinline[language=coq]|fI| de que $\forall i \in \mathbb{F}_p, f(f(i)) = i$, isto é, $f$ é involutiva.
                
                \item[\textbf{(\ref{line:16-item2})}] Introdução da hipótese \lstinline[language=coq]|fI_neq0| de que $\forall i \in \mathbb{F}_p, (i \neq 0 \rightarrow f(i) \neq i)$.
                
                \item[\textbf{(\ref{line:18-item2})}] Introdução da hipótese \lstinline[language=coq]|fB| de existência de uma função $f : (\mathbb{F}_p - \{0\}) \rightarrow (\mathbb{F}_p - \{0\})$ que é bijetora (o que é óbvio já que a função $f$ declarada anteriormente é involutiva).
                
                \item[\textbf{(\ref{line:20-item2})}] Declaração de uma função $can : \mathbb{F}_p \rightarrow \mathbb{F}_p$ tal que $can(i)$ retorna o valor mínimo entre $i$ e $f(i)$.
        \end{enumerate}

        \item Tendo agora o seguinte \textit{goal}:
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(i in 'F_p | i != 0%R) i  = a' ^ p.-1./2  %[mod p]
                \end{lstlisting}
        faz-se a seguinte reescrita:
                \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1,escapechar=@, name=proof]
have -> : \prod_(i in 'F_p | i != 0%R) i =                      @ \label{line:21-item3} @
                \prod_(j in 'F_p | (j < f j))
                        \prod_(i in 'F_p | (i != 0%R) && (can i == j)) i.
        (*... prova do subgoal...*)                             @ \label{line:24-item3} @
                \end{lstlisting}
        
        Explicando os comandos feitos em linhas específicas têm-se:
        \begin{enumerate}[listparindent=\parindent]

                \item[\textbf{(\ref{line:21-item3})}] Substituição (no \textit{goal}) de $\prod_{i \in (\mathbb{F}_p - \{0\})} i$ por:
                
                        \begin{equation*}
                        \prod_{j \in \mathbb{F}_p \mid j < f(j)} \left( \prod_{i \in (\mathbb{F}_p - \{0\}) \mid can(i)= j} i \right)
                        \end{equation*}

                \item[\textbf{(\ref{line:24-item3})}] Código da prova do \textit{subgoal} gerado na linha \ref{line:21-item3} - este código não será apresentado aqui, no entanto, pode-se dizer que tal subprova se baseia na utilização do lema \lstinline[language=coq]|partition_big|, que tem a seguinte declaração:
                
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma partition_big {R : Type} {idx : R} {op : Monoid.com_law idx} 
{I : Type} {s : seq I} {J : finType} {P : pred I} (p : I -> J) (Q : pred J) 
{F : I -> R} :
(\forall i : I, P i -> Q (p i)) ->
        \big[op/idx]_(i <- s | P i) F i =
        \big[op/idx]_(j | Q j) \big[op/idx]_(i <- s | P i && (p i == j)) F i
                        \end{lstlisting}
                onde \lstinline[language=coq]|\big[op/idx]| é parte comum de uma série de notações para uso da função \lstinline[language=coq]|bigop|, que, conforme apresentado em \cite{assia_mahboubi_2022_7118596}, pode ser definida como:
                % (apesar de não possuir exatamente esta implementação na biblioteca) como:

                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Definition bigop R I idx op r (P : pred I) (F : I -> R) : R :=
        foldr (fun i x => if P i then op (F i) x else x) idx r.
                        \end{lstlisting}
                e dentre as notações para o uso desta função tem-se:

                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Notation "\big [ op / idx ]_ ( i <- r | P ) F" :=
        (bigop idx op r (fun i => P%B) (fun i => F)) : big_scope.
                        \end{lstlisting}
                Assim, pode-se perceber que a notação de um produtório é um açúcar sintático para a uso do operador \lstinline[language=coq]|bigop| com o argumento \lstinline[language=coq]|op| sendo a operação de multiplicação e o argumento \lstinline[language=coq]|idx| sendo 1. 
                
                Nesta subprova usa-se então o lema \lstinline[language=coq]|partition_big| com \lstinline[language=coq]|P i| sendo a condição \lstinline[language=coq]|(i != 0)|, \lstinline[language=coq]|p| sendo a função \lstinline[language=coq]|can| e \lstinline[language=coq]|Q j| sendo a condição \lstinline[language=coq]|(j < f(j))|. Após o uso de tal lema é então necessário provar mais um subgoal:
                %  (que não é printado exatamente da seguinte forma mas é equivalente a tal): 
                % devido ao lema \lstinline[language=coq]|Fp_cast|):
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
forall i : 
 fintype_ordinal__canonical__fintype_Finite (Zp_trunc (pdiv p)).+2,
        (i  \in 'F_p) && (i != 0%R) -> (can i  \in 'F_p) && (can i < f (can i))
                        \end{lstlisting}
                onde a expressão:
                
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
fintype_ordinal__canonical__fintype_Finite (Zp_trunc (pdiv p)).+2
                        \end{lstlisting}
                equivale à \lstinline[language=coq]|'F_p|, pois basta realizar uma computação sobre a expressão para que ela se torne \lstinline[language=coq]|'F_p|, o que pode ser feito utilizando a tática (que usa casamento de padrões):

                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
rewrite [X in forall i : X, _]/=.
                        \end{lstlisting}

        \end{enumerate}

        \item Após a resolução dos \textit{subgoals} gerados anteriormente, o \textit{goal} atual se torna o seguinte:
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(j in 'F_p | j < f j) 
        \prod_(i in 'F_p | (i != 0%R) && (can i == j)) i
                                        = a' ^ p.-1./2  %[mod p]
                \end{lstlisting}
        Usa-se então a seguinte tática:

                \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1,name=proof, escapechar=\@]
apply: etrans (_ : \prod_(j in 'F_p | j < f j) (j * f j) = _ %[mod p]). @ \label{line:25-item4} @
        (*... prova do goal 1...*)      @ \Suppressnumber @
                        @\footnotesize \rvdots \Reactivatenumber \setcounter{lstnumber}{34}@
        (*... prova do goal 2...*)      @ \Suppressnumber @
                        @\footnotesize \rvdots \Reactivatenumber \setcounter{lstnumber}{25}@
                \end{lstlisting}
        A tática então aplicada na linha \ref{line:25-item4} utiliza da transitividade da igualdade por meio do lema \lstinline[language=coq]|etrans| junto a um argumento que permite que o \textit{Coq} infira o termo médio desta transitividade. Este argumento é uma prova de igualdade, a qual, por não existir nas hipóteses, irá gerar 2 \textit{goals} no lugar do \textit{goal} atual:

        \begin{enumerate}[label=\textbf{\roman{enumi}.(\alph*)}]
                \item Primeiro \textit{goal}:
                
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(j in 'F_p | j < f j) \prod_(i in 'F_p | (i != 0%R) && (can i == j)) i
        = \prod_(j in 'F_p | j < f j) (j * f j)  %[mod p]
                        \end{lstlisting}
                
                Para este \textit{goal} são usadas as seguintes táticas:
                
                        \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1, escapechar=\$, name=proof]
congr (_ %% _).                         $\label{line:26-item4-a}$
apply: eq_bigr => j /andP[jF jLfj].     $\label{line:27-item4-a}$
rewrite (bigD1 j); last first.          $\label{line:28-item4-a}$
        (*... prova do subgoal...*)
rewrite [LHS]/=.                        $\label{line:30-item4-a}$
rewrite (bigD1 (f j)); last first.      $\label{line:31-item4-a}$
        (*... prova do subgoal...*)
rewrite big1 /= ?muln1 // => i.         $\label{line:33-item4-a}$
        (*... prova do subgoal...*)
                        \end{lstlisting}
                
                Explicando os comandos feitos em linhas específicas têm-se:
        
                \begin{enumerate}[listparindent=\parindent]
                
                        \item[\textbf{(\ref{line:26-item4-a})}] Retirada da aplicação de $\bmod \; p$ em ambos os lados da equação.
                
                        \item[\textbf{(\ref{line:27-item4-a})}] Aplicação do lema \lstinline[language=coq]|eq_bigr| junto à eliminação do $\forall$ e introdução da hipótese gerada por tal aplicação; é interessante ao leitor não acostumado com as táticas da linguagem \textit{SSReflect} notar que, sabendo que o lema \lstinline[language=coq]|eq_bigr| tem o seguinte enunciado:
        
                                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma eq_bigr r (P : pred I) F1 F2 : (forall i, P i -> F1 i = F2 i) ->
        \big[op/idx]_(i <- r | P i) F1 i = \big[op/idx]_(i <- r | P i) F2 i.
                                \end{lstlisting}
                        após a aplicação do lema e eliminação do $\forall$, o \textit{goal} se torna:
                        
                                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
(j  \in 'F_p) && (j < f j) -> 
        \prod_(i in 'F_p | (i != 0%R) && (can i == j)) i = j * f j
                                \end{lstlisting}
                        mas nesse caso também é feita a introdução do precedente com \lstinline[language=coq]|/andP[jF jLfj]|, que torna, em tal hipótese, a expressão com operador \lstinline[language=coq]|&&| (conjunção booleana) em uma expressão equivalente com \lstinline[language=coq]|/\| (conjunção proposicional) que é então separada nas hipóteses \lstinline[language=coq]|jF| e \lstinline[language=coq]|jLfj|.
                        
                        Pode-se notar portanto que a partir da aplicação do lema \lstinline[language=coq]|eq_bigr| o \textit{goal} consiste em provar que o termo geral dos produtórios é igual.
                        
                        \item[\textbf{(\ref{line:28-item4-a})}] Reescrita por meio do lema \lstinline[language=coq]|bigD1| com o \textit{goal} sendo (devido as alterações feitas nas linhas anteriores):
                        
                                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(i in 'F_p | (i != 0%R) && (can i == j)) i = j * f j
                                \end{lstlisting}
                        Este lema basicamente retira um elemento de dentro da aplicação do operador \lstinline[language=coq]|bigop| (nesse caso o elemento \lstinline[language=coq]|j| pois foi este o argumento passado ao lema), no entanto deve-se demonstrar que tal elemento realmente ocorre em alguma das iterações, por isto é então gerado um \textit{subgoal}. Esse \textit{subgoal} normalmente deveria ser resolvido após a resolução do \textit{goal} principal, mas devido ao uso de \lstinline[language=coq]|last first| tal \textit{subgoal} deve ser resolvido antes do \textit{goal} principal.
                        
                        \item[\textbf{(\ref{line:30-item4-a})}] Comando adicionado apenas para tornar o \textit{goal} mais legível (não é algo que estava na prova original feita por Laurent), e nesse caso, após a execução dos comandos da linha 3 e deste comando, o \textit{goal} se torna:
                        
                                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
j * \prod_(i < (Zp_trunc (pdiv p)).+2 | (i != 0%R) && (can i == j) && (i != j))  i 
        = j * f j
                                \end{lstlisting}
                        em que \lstinline[language=coq]|(Zp_trunc (pdiv p)).+2| é igual a \lstinline[language=coq]|p|, o que é provado pelo lema \lstinline[language=coq]|Fp_cast|.
                        
                        \item[\textbf{(\ref{line:31-item4-a})}] Reescrita análoga a feita na linha \ref{line:28-item4-a}, porém retirando o elemento \lstinline[language=coq]|f j| do produtório, de modo que o \textit{goal} se torne então:
                        
                                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
j * ssrnat_muln__canonical__SemiGroup_ComLaw (f j)
        (\big[ssrnat_muln__canonical__SemiGroup_ComLaw/1]_(i | (i != 0%R) 
                && (can i == j) && (i != j) && (i != f j)) i) 
                        = j * f j
                                \end{lstlisting}
                        onde \lstinline[language=coq]|ssrnat_muln__canonical__SemiGroup_ComLaw| é a operação de multiplicação entre naturais.
                        
                        \item[\textbf{(\ref{line:33-item4-a})}] Reescrita do produtório ainda presente no \textit{goal} como 1 (elemento neutro) por meio do lema \lstinline[language=coq]|big1|, que por sua vez tem o seguinte enunciado:
                        
                                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma big1 {R : Type} {idx : R} {op : Monoid.law idx} I r (P : pred I) F :
        (forall i : I, P i -> F i = idx) -> 
                \big[op/idx]_(i <- r | P i) F i = idx.
                                \end{lstlisting}
                        seguindo de computação (dada por \lstinline[language=coq]|/=|), reescrita da multiplicação por 1 (omissão), resolução do goal por meio de \lstinline[language=coq]|//| (semelhante ao comando \lstinline[language=coq]|simplify|) e eliminação do $\forall$ (com "\lstinline[language=coq]|=> i|") do \textit{subgoal} aberto pelo uso do lema \lstinline[language=coq]|big1|. 
                                
                        Este \textit{subgoal} aberto consiste em provar que o termo geral é sempre igual a 1 ou que as condições do produtório nunca serão atendidas (que é o caso desta prova) e portanto o produtório retorna apenas 1. 
                        
                        Após a prova deste \textit{subgoal} resta então apenas o segundo \textit{goal} gerado na aplicação da tática \lstinline[language=coq]|etrans|.
                
                \end{enumerate}

                \item Segundo \textit{goal}:
        
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(j in 'F_p | j < f j) (j * f j)  = a' ^ p.-1./2  %[mod p]
                        \end{lstlisting}

                Para este \textit{goal} é inicialmente utilizada a aplicação do lema \lstinline[language=coq]|etrans| novamente:

                        \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1, escapechar=@, name=proof]
apply: etrans (_ : \prod_(j in 'F_p | j < f j) a' = _ %[mod p]).        @ \label{line:35-item4b} @    
        (*... prova do goal 1...*)      @ \Suppressnumber @
                @\footnotesize \rvdots \Reactivatenumber \setcounter{lstnumber}{39}@
        (*... prova do goal 2...*)      @ \Suppressnumber @
                @\footnotesize \rvdots \Reactivatenumber \setcounter{lstnumber}{35}@
                        \end{lstlisting}

                e assim, como feito em item anterior, têm-se agora dois \textit{goals} a serem resolvidos:
                
                \begin{enumerate}[label=\textbf{(\alph{enumii}.\arabic*)}]
                        
                        \item Primeiro \textit{goal}:
                
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(j in 'F_p | j < f j) (j * f j)  
        = \prod_(j in 'F_p | j < f j) a'  %[mod p]
                        \end{lstlisting}

                        Para este \textit{goal} são inicialmente aplicadas as seguintes táticas:
                
                        \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1, escapechar=@, name=proof]
rewrite -modn_prodm.                                    @ \label{line:36-item4b-item1} @
congr (_ %% _).                                         @ \label{line:37-item4b-item1} @
apply: eq_bigr => i /andP[_ iLfi].                      @ \label{line:38-item4b-item1} @
        (*... restante da prova do goal atual...*)                        
        (*... prova do goal seguinte...*)                        
                        \end{lstlisting}

                        Explicando os comandos feitos em linhas específicas têm-se:
                        \begin{enumerate}
                                \item[\textbf{(\ref{line:36-item4b-item1})}] Reescrita do termo geral do produtório do lado esquerdo como \lstinline[language=coq]|((j * f j) %% p)|.
                        
                                \item[\textbf{(\ref{line:37-item4b-item1})}] Remoção da aplicação de $\bmod \; p$ em ambos os lados da equação.
                        
                                \item[\textbf{(\ref{line:38-item4b-item1})}] aplicação do lema \lstinline[language=coq]|eq_bigr|, que por sua vez tem o seguinte enunciado:
                        
                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma eq_bigr r (P : pred I) F1 F2 : (\forall i, P i -> F1 i = F2 i) ->
        \big[op/idx]_(i <- r | P i) F1 i = \big[op/idx]_(i <- r | P i) F2 i.
                                        \end{lstlisting}
                                junto a eliminação do $\forall$ e introducão das hipóteses do  \textit{goal} alterado após a aplicação de \lstinline[language=coq]|eq_bigr|. Com isto o \textit{goal} se torna:

                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
(i * f i) %% p = a'
                                        \end{lstlisting}
                                o que é trivial considerando a hipótese \lstinline[language=coq]|fM| introduzida anteriormente.
                        \end{enumerate}
                
                        \item Segundo \textit{goal}:
                
                                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(j in 'F_p | j < f j) a'  = a' ^ p.-1./2  %[mod p]
                                \end{lstlisting}
                        Para este \textit{goal} são inicialmente utilizadas as seguintes táticas:

                                \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1, escapechar=@, name=proof, firstnumber=40]
congr (_ %% _).                                         @ \label{line:40-item4b-item2} @
rewrite prod_nat_const.                                 @ \label{line:41-item4b-item2} @
rewrite [X in fun i : X => _]/=.                        @ \label{line:42-item4b-item2} @
congr (_ ^  _).                                         @ \label{line:43-item4b-item2} @
rewrite -[p in RHS](card_Fp pP).                        @ \label{line:44-item4b-item2} @
rewrite [in RHS](cardD1 0%R).                           @ \label{line:45-item4b-item2} @
rewrite inE add1n -pred_Sn.                             @ \label{line:46-item4b-item2} @
set A := [predD1 'F_p & 0%R].                           @ \label{line:47-item4b-item2} @
pose B := [pred i |  (i : 'F_p) < f i].                 @ \label{line:48-item4b-item2} @
rewrite -(cardID B A).                                  @ \label{line:49-item4b-item2} @
have <- : #|image f [predI A & B]| = #|[predD A & B]|.  @ \label{line:50-item4b-item2} \Suppressnumber @
        (*... prova do subgoal...*)                     @ \Reactivatenumber \setcounter{lstnumber}{62} @
rewrite card_image; last by move=> i j fiEfj; rewrite -[i]fI fiEfj fI. @ \label{line:63-item4b-item2} @
rewrite addnn (half_bit_double _ false).                @ \label{line:64-item4b-item2} @
apply: eq_card => i.                                    @ \label{line:65-item4b-item2} @
rewrite !inE.                                           @ \label{line:66-item4b-item2} @
                                \end{lstlisting}
                        Explicando os comandos feitos em linhas específicas têm-se:

                        \begin{enumerate}[listparindent=\parindent]

                                \item[\textbf{(\ref{line:40-item4b-item2})}] Remoção da aplicação de $\bmod \; p$ em ambos os lados da equação.

                                \item[\textbf{(\ref{line:41-item4b-item2})}] Reescrita utilizando \lstinline[language=coq]|prod_nat_const|, lema este que possui o seguinte enunciado:
                                
                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma prod_nat_const n : \prod_(i in A) n = n ^ #|A|.
                                        \end{lstlisting}
                                em que \lstinline[language=coq]!#|A|! denota a cardinalidade de um conjunto \lstinline[language=coq]!A!. Assim o lado direito do goal se torna:

                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
a' ^ #|(fun i : fintype_ordinal__canonical__fintype_Finite 
        (Zp_trunc (pdiv p)).+2 => eqn (i.+1 - f i) 0)|
                                        \end{lstlisting}
                                onde, como já explicado anteriormente, a expressão:

                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
fintype_ordinal__canonical__fintype_Finite 
        (Zp_trunc (pdiv p)).+2
                                        \end{lstlisting}
                                é equivalente à \lstinline[language=coq]|'F_p|, e portanto, ao se executar uma computação sobre tal expressão, ela resulta em \lstinline[language=coq]|'F_p|. Esta computação é então realizada na linha \ref{line:42-item4b-item2} (qual não estava no código de Laurent), e assim, tem-se no \textit{goal}:
                                % é equivalente à \lstinline[language=coq]|'F_p|, pois ao se executar uma computação ela resulta em \lstinline[language=coq]|'F_p|. Esta computação é então realizada na linha 3, e assim, tem-se no \textit{goal}:

                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
a' ^ #|(fun i : 'F_p => eqn (i.+1 - f i) 0)| = a' ^ p.-1./2
                                        \end{lstlisting}
                                em que a expressão: 
                                
                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
eqn (i.+1 - f i) 0
                                        \end{lstlisting}
                                é a operação \lstinline[language=coq]|<| (a notação está \textit{``unfolded''}). Pode-se notar aqui que o conjunto não é definido por uma lista, mas sim por um predicado booleano, cujo domínio é um tipo finito (\lstinline[language=coq]|'F_p| neste caso).

                                \item[\textbf{(\ref{line:43-item4b-item2})}] Tranformação do \textit{goal} em uma igualdade entre os expoentes, dado que em cada lado da equação do \textit{goal} haviam exponenciações de mesma base. Com isto o \textit{goal} se torna:
                                
                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
#|(fun i : 'F_p => eqn (i.+1 - f i) 0)| = p.-1./2
                                        \end{lstlisting}

                                \item[\textbf{(\ref{line:44-item4b-item2})}] Reescrita de \lstinline[language=coq]|p| como \lstinline[language=coq]!#|'F_p|! no lado direito da equação.
                                
                                \item[\textbf{(\ref{line:45-item4b-item2})}] Reescrita de \lstinline[language=coq]!#|'F_p|! como \lstinline[language=coq]!(0%R  \in 'F_p) + #|[predD1 'F_p & 0%R]|! em que \lstinline[language=coq]![predD1 'F_p & 0%R]! é uma notação para o seguinte:
                                
                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
[fun x =>  (x != 0%R) && (x  \in 'F_p)]
                                        \end{lstlisting}
                                ou seja, \lstinline[language=coq]![predD1 'F_p & 0%R]! é o conjunto $\mathbb{F}_p - \{0\}$.

                                \item[\textbf{(\ref{line:46-item4b-item2})}] Reescrita de \lstinline[language=coq]!(0%R  \in 'F_p)! como \lstinline[language=coq]!true!, por meio da tupla \lstinline[language=coq]!inE! (\lstinline[language=coq]!inE! é uma tupla de lemas e portanto quando usada para reescrita o \textit{Coq} tenta realizar a reescrita usando cada um dos membros da tupla). O resultado desta reescrita é então convertido para 1 (devido a \textit{coercion} de \lstinline[language=coq]!bool! para \lstinline[language=coq]!nat!); reescrita da soma de 1 à esquerda na forma da notação \lstinline[language=coq]!_.+1! (pelo lema \lstinline[language=coq]!add1n!); cancelamento da adição de 1 com a subtração de 1 (pelo lema \lstinline[language=coq]!pred_Sn!, onde o uso de \lstinline[language=coq]|-| antes do nome do lema indica a direção contrária a usual da rescrita, isto é, do padrão do lado direito para o padrão do lado esquerdo). Com estas reescritas o \textit{goal} se torna:
                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
#|(fun i : 'F_p => eqn (i.+1 - f i) 0)| = #|[predD1 'F_p & 0%R]|./2
                                        \end{lstlisting}
                                
                                \item[\textbf{(\ref{line:47-item4b-item2})}] Introducão do \textit{alias} \lstinline[language=coq]|A| para o conjunto \lstinline[language=coq]|[predD1 'F_p & 0%R]|.
                                
                                \item[\textbf{(\ref{line:48-item4b-item2})}] Introducão do \textit{alias} \lstinline[language=coq]|B| para o conjunto \lstinline[language=coq]![pred i |  (i : 'F_p) < f i]! (a diferença do uso de \lstinline[language=coq]|set| e \lstinline[language=coq]|pose| é que o primeiro realiza substituição da expressão pelo \textit{alias} no \textit{goal}).
                                
                                \item[\textbf{(\ref{line:49-item4b-item2})}] Reescrita da cardinalidade de \lstinline[language=coq]!A! como a cardinalidade da intersecção entre \lstinline[language=coq]!A! e \lstinline[language=coq]!B! somada a cardinalidade de \lstinline[language=coq]!A! menos \lstinline[language=coq]!B! (por meio do lema \lstinline[language=coq]!cardID!); em termos das notações mais comuns usadas em Teoria dos Conjunto faz-se a substituição de $|A|$ por $|A \bigcap B| + |A - B|$.
                                
                                \item[\textbf{(\ref{line:50-item4b-item2})}] Substituição de \lstinline[language=coq]!#|[predD A & B]|! por \lstinline[language=coq]!#|image f [predI A & B]|! (que é printada como \lstinline[language=coq]!#|[seq f x  | x in [predI A & B]]!) em que está ultima expressão indica a imagem de \lstinline[language=coq]!f! tendo \lstinline[language=coq]!#|[predD A & B]|! como domínio. 
                                
                                Tal substituição abre um \textit{subgoal} que é resolvido em seguida, conforme indicado no comentário da linha 12 e com isso o \textit{goal} se torna:
                                % \textcolor{red}{vou colocar aqui a resolução desse \textit{subgoal} por que ele não é trivial e é bem importante para a prova}. 
                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
#|(fun i : 'F_p => eqn (i.+1 - f i) 0)| = 
        (#|[predI A & B]| + #|[seq f x  | x in [predI A & B]]|)./2
                                        \end{lstlisting}

                                % A prova do \textit{subgoal} mencionado consiste na ideia de que é possível provar que os conjuntos \lstinline[language=coq]!#|[seq f x  | x in [predI A & B]]! e \lstinline[language=coq]!#|[predD A & B]|! são iguais 
                                
                                Por não ser trivial, é útil se analisar a prova do \textit{subgoal} mencionado. Tal prova consiste no uso das seguintes táticas:
                                
                                        \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1, escapechar=@, firstnumber=50]
apply: eq_card => i.                                            @ \label{line:50-item4b-item2} @
rewrite !inE.                                                   @ \label{line:51-item4b-item2} @
rewrite -[in LHS](fI i).                                        @ \label{line:52-item4b-item2} @
rewrite mem_map; last first.                                    @ \label{line:53-item4b-item2} @
      by move=> i1 j1 fiEfj; rewrite -[i1]fI fiEfj fI.          @ \label{line:54-item4b-item2} @
rewrite mem_enum.                                               @ \label{line:55-item4b-item2} @
rewrite !inE fI !andbT.                                         @ \label{line:56-item4b-item2} @
case: (i =P 0%R) => [->|];                                      @ \label{line:57-item4b-item2} @
        first by rewrite f_eq0.                                 @ \label{line:58-item4b-item2} @
case: (f i =P 0%R) => [fi0|/eqP fi_neq0 /eqP i_neq0].           @ \label{line:59-item4b-item2} @
        by case; rewrite -(fI i) fi0 f_eq0.                     @ \label{line:60-item4b-item2} @
case: ltngtP => // /eqP/val_eqP fiEi.                           @ \label{line:61-item4b-item2} @
        by have := fI_neq0 i i_neq0; rewrite fiEi eqxx.         @ \label{line:62-item4b-item2} @
                                        \end{lstlisting}
                                Explicando determinadas linhas (com o item de cada uma destas linhas) da subprova têm-se:
                                        \begin{itemize}
                                                \item[\textbf{(\ref{line:50-item4b-item2})}] Transformação do \textit{goal} de uma igualdade entre cardinalidade em uma igualdade de conjunto, isto é, em:
                                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
(i  \in [seq f x  | x in [predI A & B]]) = (i  \in [predD A & B])
                                                        \end{lstlisting}        
                                                
                                                \item[\textbf{(\ref{line:51-item4b-item2})}] Simplificação de expressões como \lstinline[language=coq]|x \in 'F_p| (que aparecem na expressão \textit{``unfolded''}) em \lstinline[language=coq]|true|. Com isso o \textit{goal} se torna:
                                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
(i  \in [seq f x  | x in [predI A & B]]) 
        = [&& ~~ (i < f i),  i != 0%R  & true]
                                                        \end{lstlisting}
                                                        
                                                \item[\textbf{(\ref{line:52-item4b-item2})}] Reescrita de \lstinline[language=coq]|i| como \lstinline[language=coq]|f (f i)| no lado esquerdo do \textit{goal}.
                                                
                                                \item[\textbf{(\ref{line:53-item4b-item2})}] Reescrita de:
                                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
(f (f i)  \in [seq f x  | x in [predI A & B]])
                                                        \end{lstlisting}
                                                como:
                                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
((f i)  \in enum [predI A & B])
                                                        \end{lstlisting}
                                                o que é possível pois \lstinline[language=coq]|f| é injetora (\textit{subgoal} aberto por este \lstinline[language=coq]|rewrite| e provado na linha \ref{line:54-item4b-item2}). Com isto o
                                                \textit{goal} se torna:
                                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
(f i  \in enum [predI A & B]) = [&& ~~ (i < f i),  i != 0%R  & true]
                                                        \end{lstlisting}
                                                onde \lstinline[language=coq]|enum| é uma função que retorna os elementos do tipo finito que atende a proposição booleana passada como argumento (o tipo finito é inferido pelo tipo do argumento de tais proposições), conforme consta na documentação da biblioteca\footnote{\url{https://math-comp.github.io/htmldoc_2_2_0/mathcomp.ssreflect.fintype.html}}.

                                                \item[\textbf{(\ref{line:55-item4b-item2})}] Reescrita de \lstinline[language=coq]|(f i  \in enum [predI A & B])| como \lstinline[language=coq]|(f i  \in [predI A & B])|.
                                                
                                                \item[\textbf{(\ref{line:56-item4b-item2})}] Reescritas atráves da tupla \lstinline[language=coq]|inE|, reescrita de \lstinline[language=coq]!f (f i)! com \lstinline[language=coq]!i! e por fim reescritas de conjunções booleanas com um dos elementos sendo \lstinline[language=coq]!true!. Assim obtêm-se o seguinte \textit{goal}:
                                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
(f i != 0%R) && (f i < i) = ~~ (i < f i) && (i != 0%R)
                                                        \end{lstlisting}
                                                O \textit{goal} é agora considerávelmente trivial e pode ser resolvido por análise de caso, o que é feito nas linhas seguintes.

                                                \item[\textbf{(\ref{line:57-item4b-item2})}] Análise dos dois seguintes casos: \lstinline[language=coq]|i = 0%R| e \lstinline[language=coq]|i <> 0%R|, feito por meio do comando \lstinline[language=coq]|case| sobre a expressão \lstinline[language=coq]|i =P 0%R|. É resolvido o primeiro caso e então \lstinline[language=coq]|i <> 0%R| é uma hipótese no restante da resolução.
                                                
                                                \item[\textbf{(\ref{line:59-item4b-item2})}] Análise dos dois seguintes casos análoga a linha anterior porém sobre o termo comando \lstinline[language=coq]|f i| ao invés de comando \lstinline[language=coq]|i|.
                                                
                                                \item[\textbf{(\ref{line:61-item4b-item2})}] Análise dos casos:
                                                \lstinline[language=coq]|i < f i|, \lstinline[language=coq]|i > f i| e por último \lstinline[language=coq]|i = f i|.
                                                Os dois primeiros casos são resolvidos com a simplificação \lstinline[language=coq]|//| na mesma linha do \lstinline[language=coq]|case|, por isso se introduz a hipótese \lstinline[language=coq]|fiEi| apenas. Esta hipótese ao ser introduzida é reescrita por meio de \lstinline[language=coq]|/eqP| e \lstinline[language=coq]|/val_eqP|, o que retira a \textit{coercion} para \lstinline[language=coq]|nat| aplicada sobre \lstinline[language=coq]|f i| e sobre \lstinline[language=coq]|i|. A partir disso o \textit{goal} é resolvido na linha \ref{line:62-item4b-item2} obtêndo a partir da hipótese \lstinline[language=coq]|fI_neq0| (introduzida no perto do começo do código) e \lstinline[language=coq]|i_neq0| (de que \lstinline[language=coq]|i != 0|, introduzida na linha \ref{line:59-item4b-item2}) para então se obter uma contradição junto a hipótese \lstinline[language=coq]|fiEi|. Com isto a prova do \textit{subgoal} se encerra.

                                        \end{itemize}
                                
                                \item[\textbf{(\ref{line:63-item4b-item2})}] Reescrita (e resolução do \textit{subgoal} aberto por tal tatíca) de:

                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
#|[seq f x  | x in [predI A & B]]|
                                        \end{lstlisting}
                                como \lstinline[language=coq]!#|[predI A & B]|!. Em termos de notações comumente usadas em Teoria dos Conjuntos, substitui-se $|Im(f, A \bigcap B)|$ por $|A \bigcap B|$ (o que é possível por $f$ é injetora). Com isso o \textit{goal} se torna:
                                
                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
#|(fun i : 'F_p => eqn (i.+1 - f i) 0)| = 
        (#|[predI A & B]| + #|[predI A & B]|)./2
                                        \end{lstlisting}
                                
                                \item[\textbf{(\ref{line:64-item4b-item2})}] Reescrita da expressão:
                                        
                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
(#|[predI A & B]| + #|[predI A & B]|)./2
                                        \end{lstlisting}
                                como \lstinline[language=coq]!|[predI A & B]|!.
                                
                                \item[\textbf{(\ref{line:65-item4b-item2})}] Reescrita da igualdade entre 2 conjuntos como uma igualdade entre expressões booleanas de pertencimento de um elemento (instânciado após a eliminação do $\forall$ na mesma linha) a cada conjunto. Assim o \textit{goal} se torna:
                                
                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
(i \in (fun i0 : 'F_p => eqn (i0.+1 - f i0) 0)) = (i \in [predI A & B])
                                        \end{lstlisting}

                                \item[\textbf{(\ref{line:66-item4b-item2})}] Ambas as expressões da igualdade podem ser simplificadas com o uso da tupla \lstinline[language=coq]|inE| diversas vezes, por isso para realizar o máximo de reescritas possíveis é utilizado ``\lstinline[language=coq]|!|'' antes do nome da tupla. Obtêm-se então a seguinte expressão no \textit{goal}:
                                
                                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
(i < f i) = (i != 0%R) && true && (i < f i)
                                        \end{lstlisting}
                                que é por sua vez trivial considerando as hipóteses \lstinline[language=coq]|f_eq0| e \lstinline[language=coq]|fI_neq0| introduzidas no início. Após isso a prova se encerra.
                                
                        \end{enumerate}

                \end{enumerate}

        \end{enumerate}


%                         \begin{lstlisting}[language=coq,frame=single,tabsize=1]
% \prod_(j in 'F_p | j < f j) (j * f j)  = a' ^ p.-1./2  %[mod p]
%                         \end{lstlisting}

\end{enumerate}

        Com uso do lema \coqinline[]{fact_sqr_exp} e do teorema \coqinline[]{Wilson} foi provada por Laurent Théry a seguinte versão do \textit{Critério de Euler} (Teorema \ref{teorema:criteriodeeuler}) para números naturais:
        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma euler_criterion a p : 
        prime p -> ~~ (p %| a) -> 
        a ^ p.-1./2 = (if res_quad p a then 1 else p.-1) %[mod p].
        \end{lstlisting}

% Alguns lemas, teoremas e definições que já haviam sido implementados na biblioteca, junto a um que foi implementado durante o período de realização deste trabalho (e portanto possívelmente, na data de publicação deste trabalho, ainda não está incluído na biblioteca) foram de grande importância para alcance dos objetivos estabelecidos. Sendo assim, é de interesse que sejam aqui mencionados.

\section{Formalização do Símbolo de Legendre}
\label{sec:form-legendre}

A formalização a ser apresentada seguiu a ideia utilizada (e recomendada) por Laurent Théry, de se utilizar uma função exaustiva para verificar se um determinado número é um resíduo quadrático módulo $p$. Com isso, tem-se uma função que é pelo menos computável (apesar de sua ineficiência). Fez-se então neste trabalho a seguinte implementação do \textit{símbolo de Legendre}:
% Seguindo a ideia utilizada (e recomendada) por Laurent Théry, em se utilizar uma função exaustiva para verificar se um determinado número é um resíduo quadrático módulo $p$ (em que $p$ é um número primo), e portanto, ter-se uma função que é pelo menos computável (apesar de sua ineficácia), fez-se neste trabalho a seguinte definição para o \textit{símbolo de Legendre}:
        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Definition legendre_symb {p : int} (pL2 : (2 < p)%R) (pP : primez p) 
        (a : int) :=
        if (p %| a)%Z then 0%Z
        else if (resz_quad p a)
        then 1%Z
        else (-1)%Z.
        \end{lstlisting}
onde \lstinline[language=coq]|resz_quad| é a uma versão da função \lstinline[language=coq]|res_quad| (mencionado na Seção \ref{sec:implementacoes}), porém que recebe como argumento valores de tipo \lstinline[language=coq]|int|. A sua definição é:
        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Definition resz_quad p a := has (fun i => ((i * i)%:Z  == a %[mod p])%Z) (iota 0 `|p|).
        \end{lstlisting}
Nesta implementação, o \textit{símbolo de Legendre} é portanto uma função que recebe um número inteiro $p$, uma prova de que $2 < p$, uma prova de que $p$ é um número primo e por último um número inteiro $a$, retornando um valor inteiro. Note que os argumentos que constituem provas podem ser gerados automaticamente pelo usuário dado que as funções \lstinline[language=coq]!<! e \lstinline[language=coq]!primez! são computáveis. Como exemplo de uso da função tem-se portanto:
        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Compute (legendre_symb (_ : 2 < 7)%R (_ : primez 7) 2).
        \end{lstlisting}
que neste caso irá retornar $1$.

% Havendo a definição de \textit{símbolo de Legendre} resta então provar as suas principais propriedades, que podem vir a ser úteis em trabalhos futuros. Se baseando em \cite{book:2399854}, as principais propriedades do \textit{símbolo de Legendre}, considerando um número primo $p > 2$, são, para todo $a, b \in \mathbb{Z}$:
Havendo a definição de \textit{símbolo de Legendre} provou-se então a corretude da função que o implementa, qual foi feita utilizando o tipo indutivo \coqinline[]{reflect} pois teoremas sobre a habitantes desse tipo podem são usados em táticas da linguagem \textit{SSReflect}. Esse tipo tem a seguinte definição:
        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Inductive reflect (P : Prop) : bool -> Set :=
        | ReflectT : P -> reflect P true
        | ReflectF : ~ P -> reflect P false.
        \end{lstlisting}
A corretude foi então separada em 2 enunciados para melhor usabilidade em outras provas:
        \begin{lstlisting}[language=coq,frame=single,tabsize=1, escapechar=@]
Theorem legendre_symbP {p : int} (pL2 : (2 < p)%R) (pP : primez p) (a : int):
    reflect (exists x, x^2 = a %[mod p]) (if (p %| a)%Z then
        ((legendre_symb pL2 pP a) == 0) else ((legendre_symb pL2 pP a) == 1)).
Proof.
@ \rvdots @
Qed.

Theorem legendre_symbPn {p : int} (pL2 : (2 < p)%R) (pP : primez p) (a : int):
    reflect (~ exists x, x^2 = a %[mod p]) ((legendre_symb pL2 pP a) == -1).
Proof.
@ \rvdots @
Qed.
        \end{lstlisting}
        
Foram também provadas as principais propriedades apresentadas em \cite[p.~87-88]{book:2399854} sobre \textit{símbolo de Legendre}. Listando os enunciados dessas propriedades, para um número primo $p > 2$, são, para todo $a, b \in \mathbb{Z}$:
% 87 é onde está o critério de Euler 
% Havendo a definição de \textit{símbolo de Legendre} resta então provar as suas principais propriedades. Se baseando em \cite{book:2399854}, as principais propriedades do \textit{símbolo de Legendre}, considerando um número primo $p > 2$, são, para todo $a, b \in \mathbb{Z}$:
        \begin{enumerate}
        \item $a \equiv b \pmod{p} \rightarrow \left(\frac{a}{p}\right) = \left(\frac{b}{p}\right)$, cuja declaração dada em \textit{Coq} é:
        \newline
                % \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
                % \begin{lstlisting}[language=coq]
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma legendre_symbE (p a b : int) (pL2 : (2 < p)%R) (pP : primez p):
        (a == b %[mod p])%Z -> 
                ((legendre_symb pL2 pP a) == (legendre_symb pL2 pP b)).
                \end{lstlisting}
                % \end{tcolorbox}
        
        \item $p \nmid a \rightarrow \left(\frac{a^2}{p}\right)$, cuja declaração dada em \textit{Coq} é:
        \newline
                % \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
                % \begin{lstlisting}[language=coq]
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma legendre_symb_Ndvd (p a b : int) (pL2 : (2 < p)%R) (pP : primez p):
        ~~(p %| a)%Z -> (legendre_symb pL2 pP (a^2)) == 1.
                \end{lstlisting}
                % \end{tcolorbox}
        
        \item $\left(\frac{-1}{p}\right) = (-1)^{\frac{p - 1}{2}} = 1 \leftrightarrow p \equiv 1 \pmod{p}$, cuja declaração dada em \textit{Coq} é:
        \newline
                % \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
                % \begin{lstlisting}[language=coq]
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma legendre_symb_Neg1 (p : int) (pL2 : (2 < p)%R) (pP : primez p):
        ((legendre_symb pL2 pP (-1)) == 1) = (p == 1 %[mod 4])%Z.
                \end{lstlisting}
                % \end{tcolorbox}
        
        % \item $\left(\frac{-1}{p}\right) = (-1)^{\frac{p - 1}{2}} = -1 \leftrightarrow p \equiv 3 \pmod{p}$ 

        % \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
        %       \begin{lstlisting}[language=coq]
        %       \end{lstlisting}
        % \end{tcolorbox}
        
        \item $\left(\frac{a \cdot b}{p}\right) = \left(\frac{a}{p}\right) \cdot \left(\frac{b}{p}\right)$, cuja declaração dada em \textit{Coq} é:
        \newline
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma legendre_symb_mul (p a b : int) (pL2 : (2 < p)%R) (pP : primez p):
        (legendre_symb pL2 pP (a * b)%R) = 
                ((legendre_symb pL2 pP a) * (legendre_symb pL2 pP b))%R.
                \end{lstlisting}
        \end{enumerate}
        Também foi provado o \textit{Critério de Euler} (Lema \ref{teorema:criteriodeeuler}), com enunciado idêntico ao apresentado em \cite[p.~87]{book:2399854}, utilizando a versão implementada por Laurent Théry para números naturais (\coqinline[]{euler_criterion}):
        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma eulerz_criterion {p : int} (pL2 : (2 < p)%R) (pP : primez p) (a : int):
    (a ^ ((p - 1) %/ 2)%Z = (legendre_symb pL2 pP a) %[mod p])%Z.
        \end{lstlisting}

        Nas provas destas propriedades foram utilizadas implementações da biblioteca Mathematical Components (sendo importados os módulos \textit{all\_ssreflect} e \textit{all\_algebra}), do repositório \textit{mathcomp-extra} (disponível em \url{https://github.com/thery/mathcomp-extra} e que contém os conteúdos apresentados na Seção \ref{sec:implementacoes}) e por fim o módulo \textit{primez} disponível no repositório disponibilizado neste trabalho.

        Apesar de longas, as provas realizadas para tais lemas não são de uma complexidade que torne oportuno tratar sobre estas aqui. No entanto convém relatar que, justamente pelo tamanho de tais provas e outros detalhes relacionados a boas práticas para contribuições na biblioteca Mathematical Components (assunto tratado em \url{https://github.com/math-comp/math-comp/blob/master/CONTRIBUTING.md}), essas implementações provavelmente deverão ser refatoradas para que possam ser incluídas na biblioteca.

% A formalização (isto é, prova) de todos estes lemas está disponível em: \url{https://github.com/bruniculos08/TCC2005/blob/main/C\'{o}digo - Parte 02/InversoMultiplicativo.v}.

