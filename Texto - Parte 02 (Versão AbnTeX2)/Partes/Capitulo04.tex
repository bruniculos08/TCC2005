\chapter{Implementação}
\label{cap:implementacao}

Neste capítulo será tratada a implementação do \textit{símbolo de Legendre}, trazendo um conteúdo dividido em três partes: apresentação do sistema de hierarquia de estruturas algébricas, discussão sobre implementações de outros conteúdos externos a este trabalho consideradas fundamentais para realização do objetivo proposto, e por fim as implementações realizadas no presente trabalho.
        
Anteriormente vale ressaltar que existem implementações sobre \textit{símbolo de Legendre} fora da biblioteca Mathematical Components. Como exemplo de tais implementações tem-se, utilizando o auxiliador de provas \textit{Lean}, na biblioteca Mathlib\footnote{Disponível em: https://github.com/leanprover-community/mathlib4}, tanto a implementação de \textit{símbolo de Legendre} quanto da \textit{Lei de Reciprocidade Quadrática}
(tema este discutido no Apêndice \ref{cap:reciprocidadequadratica}). Há também a implementação de ambos os conteúdos mencionados em \textit{Coq} (porém sem utilização da biblioteca Mathematical Components) públicada em repositório\footnote{Disponível em: https://github.com/Ekdohibs/coq-proofs/tree/master/Reciprocity} de Nathanaëlle Courant disponível no GitHub.

\section{Hierarquias entre Estruturas Algébricas}

Ao se utilizar a biblioteca Mathematical Components pela primeira vez o usuário tende a necessitar corriqueiramente da ferramenta de busca de teoremas, lemas e definições. Isto tende acontecer pois em geral o usuário precisa aprendar os nomes (e padrões destes) utilizados na biblioteca e o como são implementados. Como exemplo suponha que queira-se rescrever uma expressão com números naturais utilizando a propriedade de comutatividade: o lema para isto é dado por \lstinline[language = coq]!addnC! e pode ser notado como o lema que se deseja utilizar por sua definição:
\begin{lstlisting}[language=coq]
        Lemma addnC : commutative addn.
\end{lstlisting}
Agora, supondo que se tenha a mesma situação envolvendo números inteiros. É provável que não seja tão simples para o mesmo usuário encontrar o lema desejado, pois nesse caso, apesar da existência do lema \lstinline[language = coq]!addzC! com definição:
\begin{lstlisting}[language=coq]
        Lemma addzC : commutative addz.
\end{lstlisting}
pelo fato da notação \lstinline[language = coq]!+! não ser definida para a operação \lstinline[language = coq]!addz! (operação de soma entre inteiros) mas sim para determinadas operações binárias de estruturas semelhantes ao \textit{record} apresentado na Subseção \ref{sub:grupos}, tal lema não irá servir (exceto caso o usuário esteja utilizando a função \lstinline[language = coq]!addz! e não a notação \lstinline[language = coq]!+!).

Sendo assim, para realizar a manipulação desejada, deve-se utilizar o lema \lstinline[language = coq]!addrC!, qual possui a seguinte definição: 
\begin{lstlisting}[language=coq]
        forall s : nmodType, commutative +%R
\end{lstlisting}
Note que o lema é definido pra uma estrutura \lstinline[language = coq]!nmodType!; estruturas como essa são muito comuns nos códigos da Mathematical Components, e, conforme apresentado no guia de contribuições da biblioteca\footnote{Disponível em: https://github.com/math-comp/math-comp/blob/master/CONTRIBUTING.md}, pode-se verificar, utilizando a linguagem HB \cite{cohen_et_al:LIPIcs.FSCD.2020.34} para hierarquia de estruturas algébricas, os lemas que caracterizam \lstinline[language = coq]!nmodType!, usando o seguinte comando: 
\begin{lstlisting}[language=coq]
        HB.about nmodType.
\end{lstlisting}
que irá apresentar uma mensagem contendo, em parte dela, o seguinte conteúdo:
\begin{lstlisting}[language=coq-error]
        HB: nmodType is a structure (from "./ssralg.v", line 589)
        HB: nmodType characterizing operations and axioms are:
        - add0r
        - addrC
        - addrA
        - add
        - zero
\end{lstlisting}
Verificando as definições dos nomes apresentados nesta mensagem podemos notar que tal estrutura possui uma operação (\lstinline[language = coq]!add!), um elemento neutro à esquerda (\lstinline[language = coq]!zero! e \lstinline[language = coq]!add0r!) e as propriedades de comutatividade e associatividade para tal operação (\lstinline[language = coq]!addrC! e \lstinline[language = coq]!addrA!).
Usando o mesmo comando (\lstinline[language = coq]!HB.about!) sobre o tipo \lstinline[language = coq]!int!, tem-se como resultado na mensagem apresentada as estruturas com as quais o tipo está ``equipado'', e dentre estas tem-se \lstinline[language = coq]!GRing.Nmodule! (para qual \lstinline[language=coq]!nmodType! é um sinônimo). 

Tal organização presente na biblioteca, ao ser conhecida pelo usuário, torna mais fácil e organizada a manipulação de diferentes tipos, e é portanto uma informação importante para leitores deste trabalho que desejam futuramente fazer uso da mesma biblioteca. 

\textcolor{red}{ Ainda da pra mexer nessa subseção, pra citar mais referências apesar de eu não ter precisado tanto por que as informações são meio obvias após algum tempo de uso da biblioteca, acho q é interessante citar pra dar mais segurança ao leitor (e a mim mesmo também)}

\textcolor{darkgreen}{\textbf{IDEIA}: jogar essa seção para o Capítulo 2.}
% conforme apresentado em \cite{2023multipleinheritancehazardsdependentlytypedalgebraic}, são utilizadas para 

\section{Implementações Externas de Maior Relevância}
Dentre os teoremas e lemas utilizados neste trabalho (dos quais a grande maioria são lemas simples da biblioteca Mathematical Components), existe um lema e um teorema que merecem destaque devido a complexidade para a prova dos mesmos, haja vista a dificuldade em se fazer uma formalização com base na ideia da prova manual destes (ambas apresentadas neste trabalho).

O primeiro destes trata do caso \ref{item:caso3wilson} do Teorema \ref{teorema : wilson} e tem na biblioteca a seguinte declaração:
\begin{lstlisting}[language=coq]
        Theorem Wilson p : p > 1 -> prime p = (p %| ((p.-1)`!).+1).
\end{lstlisting}
É importante notar, que, nesse contexto, dada a presença da \textit{coercion} \lstinline[language=coq]!is_true!, a igualdade entre as proposições booleanas \lstinline[language=coq]!prime p! e \lstinline[language=coq]!p %| ((p.-1)`!).+1! significa uma bi-implicação caso estas proposições não fossem booleanas. Além, vale aqui lembrar da definição de equivalência em módulo $p$, e que portanto:
\begin{equation}
        p \mid (p-1)! + 1 \Longleftrightarrow (p-1)! \equiv -1 \pmod{p} 
\end{equation}

Quanto ao segundo item a ser mencionado, este trata do Lema \ref{lema : modp-1fat} e foi provado por Laurent Théry durante o período de realiazação deste trabalho. A prova deste está disponível em: \hyperlink{https://github.com/thery/mathcomp-extra/blob/master/euler.v}{https://github.com/thery/mathcomp-extra/blob/master/euler.v} e tem a seguinte declaração:
\begin{lstlisting}[language=coq]
        Lemma fact_sqr_exp a p :
        prime p -> ~~ (p %| a) -> ~~ res_quad p a -> (p.-1`!) = a ^ p.-1./2 %[mod p].
\end{lstlisting}
onde \lstinline[language=coq]!res_quad! tem a seguinte definição:
\begin{lstlisting}[language=coq]
        Definition res_quad p a := has (fun i => i * i == a %[mod p]) (iota 0 p).
\end{lstlisting}
em que, a função \lstinline[language=coq]!has! recebe um predicado booleano e uma lista, e então retorna \lstinline[language=coq]!true!
se há algum elemento da lista que satisfaz o predicado e \lstinline[language=coq]!false! caso contrário. Já a função \lstinline[language=coq]!iota! recebe dois números naturais $m$ e $n$ e retorna uma lista crescente de todos os naturais de $m$ até $n-1+m$. Portanto, a função \lstinline[language=coq]!res_quad! é um método exaustivo para verificar se há um valor $r$ tal que $r^{2} \equiv a \pmod{p}$.

As dificuldades relacionadas as provas destas declarações em \textit{Coq}, se baseando nas ideias de provais manuais apresentadas neste trabalho, deve-se ao fato de que tais ideias sugerem a reorganização de todos os termos de produtórios com tamanho arbitrário. E tais provas além de dificeís não podem ser evitadas ao se buscar a implementação de \textit{símbolo de Legendre} em \textit{Coq} dado que tratam de conteúdos diretamente conectados (principalmente ao se considerar o Teorema \ref{teorema:criteriodeeuler}).

Devido a essa dificuldade, que pode vir a aparecer em diversas situações onde tem-se uma ideia de prova semelhante a ser formalizada, é de interesse se ter conhecimento de como as provas do Teorema \ref{teorema : wilson} e do Lema \ref{lema : modp-1fat} foram feitas em \textit{Coq}. Para satisfazer essa necessidade será aqui explicada em detalhe (com excessão de \textit{subgoals} básicos e outras partes triviais) o conteúdo da prova do Lema \ref{lema : modp-1fat} realizada por Laurent Théry. O código da prova pode-ser divido nas seguintes etapas:

\begin{enumerate}
        \item Inicialmente tem-se o seguinte \textit{goal}:
        \begin{tcolorbox}[colback=green!50!white,colframe=green!100!black,width=14.7cm]
        \begin{lstlisting}[language=coq]
prime p -> ~~ (p %| a) -> ~~ res_quad p a -> (p.-1`!) = a ^ p.-1./2 %[mod p]
        \end{lstlisting}
        \end{tcolorbox}
        introduz-se então todas as hipóteses e se reescreve $(p-1)!$ como um produtório de entre todos os elementos diferentes de $0$ em $\mathbb{F}_p$:
        \begin{lstlisting}[language=coq]
move=> pP pNDa aR. (* introducao das hipoteses em ordem *)
have -> : p.-1`! = \prod_(i in 'F_p | i != 0%R) i.  (* substituicao de (p.-1`!) 
        pelo produtorio de i \in 'F_p tal que i != 0%R *) 
        (* ... prova do subgoal aberto pela substituicao... *)
        \end{lstlisting}
        % (*      
        % Obs.: o comando "have" funciona de maneira semelhante ao comando
        % "assert", e pode receber um nome para uma nova hipotese, nada
        % (assim o conteudo sera colocado como precedente do goal) e -> 
        % ou <- para se fazer um substituicao    
        % *)

        \item Tendo agora o seguinte \textit{goal}:
        \begin{tcolorbox}[colback=green!50!white,colframe=green!100!black,width=14.7cm]
        \begin{lstlisting}[language=coq]
\prod_(i in 'F_p | i != 0%R) i  = a ^ p.-1./2  %[mod p]
        \end{lstlisting}
        \end{tcolorbox}
        faz-se então uma série de declarações de constantes e funções e introducão de novas hipóteses:
        \begin{lstlisting}[language=coq]
pose a' : 'F_p := inZp a. (* declaracao de uma variavel a' de tipo 'F_p: *)
have a'E : a' = a %% p :> nat (* introducao de hipotese com nome a'E; note 
        que ":> nat" indica a aplicacao de coercion para nat em ambos os 
        lados da igualdade *)
        by rewrite /= Fp_cast.
have a'_neq0 : a' != 0%R. (* note que 0%R tem tipo 'F_p *)
        (*... prova do subgoal para introducao da hipotese a'_neq0...*)
rewrite -modnXm -a'E. (* reescrita de a^p.-1./2 como a'^p.-1./2 *)
pose f (i : 'F_p) : 'F_p := (a' / i)%R. (* declaracao de funcao que recebe i e 
        retorna a * i^-1, onde i * i^-1 (o que e possivel pois para todo 
        elemento i de 'F_p existe um inverso i^-1) *)
have f_eq0 : f 0%R = 0%R by rewrite /f GRing.invr0 GRing.mulr0. 
have fM (i : 'F_p) : i != ord0 -> (f i * i = a')%R. (* ord0 e uma notacao 
        para 0%R *)
        (*... prova do subgoal para introducao da hipotese fM...*)
have fI (i : 'F_p) : f (f i) = i.
        (*... prova do subgoal para introducao da hipotese fI...*)
have fI_neq0 (i : 'F_p) : i != 0%R -> f i != i.
        (*... prova do subgoal para introducao da hipotese fI_neq0...*)
have fB : {on [pred i |  i != ord0],  bijective f}.
        (* a notacao de fB tem o seguinte significado: existe uma funcao f, 
        tal que esta e bijetora se o argumento i obedece a restricao 
        imposta (i != ord0).*)
        by exists f => j _; apply: fI.
        (* note que o subgoal e resolvido com a tatica 'exists', tendo como 
        argumento a funcao f anteriormente declarada, e com a aplicacao da 
        hipotese fI que indica que f e involutiva. *)
pose can (i : 'F_p) :=  if i < (f i) then i else f i. (* declaracao de uma funcao 
        que recebe i e retorna o minimo entre i e f i *)

        \end{lstlisting}

        \item 
\end{enumerate}

% Alguns lemas, teoremas e definições que já haviam sido implementados na biblioteca, junto a um que foi implementado durante o período de realização deste trabalho (e portanto possívelmente, na data de publicação deste trabalho, ainda não está incluído na biblioteca) foram de grande importância para alcance dos objetivos estabelecidos. Sendo assim, é de interesse que sejam aqui mencionados.

\section{Formalização do Símbolo de Legendre}

Seguindo a ideia utilizada (e recomendada) por Laurent Théry, em se utilizar uma função exaustiva para verificar se um determinado número é um resíduo quadrático módulo $p$ (em que $p$ é um número primo), e portanto, ter-se uma função que é pelo menos computável (apesar de sua ineficácia), fez-se neste trabalho a seguinte definição para o \textit{símbolo de Legendre}:
\begin{lstlisting}[language=coq]
        Definition legendre_symb {p : int} (pL2 : (2 < p)%R) (pP : primez.primez p) 
        (a : int) :=
        if (p %| a)%Z then 0%Z
        else if has (fun i => ((i * i)%:Z  == a %[mod p])%Z) (iota 0 `|p|)
        then 1%Z
        else (-1)%Z.
\end{lstlisting}
Com esta definição, o \textit{símbolo de Legendre} é portanto uma função que recebe um número inteiro $p$, uma prova de que $2 < p$, uma prova de que $p$ é um número primo e por último um número inteiro $a$. Note que os argumentos que constituem provas podem ser gerados automaticamente pelo usuário dado que as funções \lstinline[language=coq]!<! e \lstinline[language=coq]!primez! são computáveis. Como exemplo de uso da função tem-se portanto:
\begin{lstlisting}[language=coq]
        Compute (legendre_symb (_ : 2 < 7)%R (_ : primez.primez 7) 2).
\end{lstlisting}
que neste caso irá retornar $1$.

Havendo a definição de \textit{símbolo de Legendre} resta então provar as suas principais propriedades, que podem vir a ser úteis em trabalhos futuros. Se baseando em \cite{book:2399854}, as principais propriedades do \textit{símbolo de Legendre}, considerando um número primo $p > 2$, são, para todo $a, b \in \mathbb{Z}$:
\begin{enumerate}
        \item $a \equiv b \pmod{p} \rightarrow \left(\frac{a}{p}\right) = \left(\frac{b}{p}\right)$, cuja declaração dada em \textit{Coq} é:
        \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
        \begin{lstlisting}[language=coq]
Lemma legendre_symbE (p a b : int) (pL2 : (2 < p)%R) 
(pP : primez.primez p):
(a == b %[mod p])%Z -> 
        ((legendre_symb pL2 pP a) == (legendre_symb pL2 pP b)).
        \end{lstlisting}
        \end{tcolorbox}
        
        \item $p \nmid a \rightarrow \left(\frac{a^2}{p}\right)$, cuja declaração dada em \textit{Coq} é:
        \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
        \begin{lstlisting}[language=coq]
Lemma legendre_symb_Ndvd (p a b : int) (pL2 : (2 < p)%R) 
(pP : primez.primez p):
~~(p %| a)%Z -> (legendre_symb pL2 pP (a^2)) == 1.
        \end{lstlisting}
        \end{tcolorbox}
        
        \item $\left(\frac{-1}{p}\right) = (-1)^{\frac{p - 1}{2}} = 1 \leftrightarrow p \equiv 1 \pmod{p}$, cuja declaração dada em \textit{Coq} é:
        \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
        \begin{lstlisting}[language=coq]
Lemma legendre_symb_Neg1 (p : int) (pL2 : (2 < p)%R) 
(pP : primez.primez p):
((legendre_symb pL2 pP (-1)) == 1) = (p == 1 %[mod 4])%Z.
        \end{lstlisting}
        \end{tcolorbox}
        
        % \item $\left(\frac{-1}{p}\right) = (-1)^{\frac{p - 1}{2}} = -1 \leftrightarrow p \equiv 3 \pmod{p}$ 
        
        \item $\left(\frac{a \cdot b}{p}\right) = \left(\frac{a}{p}\right) \cdot \left(\frac{b}{p}\right)$, cuja declaração dada em \textit{Coq} é:
        \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
        \begin{lstlisting}[language=coq]
Lemma legendre_symb_Neg1 (p : int) (pL2 : (2 < p)%R) 
(pP : primez.primez p):
((legendre_symb pL2 pP (-1)) == 1) = (p == 1 %[mod 4])%Z.
        \end{lstlisting}
        \end{tcolorbox}
\end{enumerate}

A formalização (isto é, prova) de todos estes lemas está disponível no seguinte \hyperlink{https://github.com/bruniculos08/TCC2005/blob/main/Código - Parte 02/InversoMultiplicativo.v}{repositório}.

