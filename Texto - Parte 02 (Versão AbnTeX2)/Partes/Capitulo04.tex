\chapter{Implementação}
\label{cap:implementacao}

Neste capítulo será tratada a implementação do \textit{símbolo de Legendre}, trazendo um conteúdo dividido em três partes: apresentação do sistema de hierarquia de estruturas algébricas, discussão sobre implementações de outros conteúdos externos a este trabalho consideradas fundamentais para realização do objetivo proposto, e por fim as implementações realizadas no presente trabalho.
        
Anteriormente vale ressaltar que existem implementações sobre \textit{símbolo de Legendre} fora da biblioteca Mathematical Components. Como exemplo de tais implementações tem-se, utilizando o auxiliador de provas \textit{Lean}, na biblioteca Mathlib\footnote{Disponível em: https://github.com/leanprover-community/mathlib4}, tanto a implementação de \textit{símbolo de Legendre} quanto da \textit{Lei de Reciprocidade Quadrática}
(tema este discutido no Apêndice \ref{cap:reciprocidadequadratica}). Há também a implementação de ambos os conteúdos mencionados em \textit{Coq} (porém sem utilização da biblioteca Mathematical Components) públicada em repositório\footnote{Disponível em: https://github.com/Ekdohibs/coq-proofs/tree/master/Reciprocity} de Nathanaëlle Courant disponível no GitHub.

\section{Hierarquias entre Estruturas Algébricas}

Ao se utilizar a biblioteca Mathematical Components pela primeira vez o usuário tende a necessitar corriqueiramente da ferramenta de busca de teoremas, lemas e definições. Isto tende acontecer pois em geral o usuário precisa aprendar os nomes (e padrões destes) utilizados na biblioteca e o como são implementados. Como exemplo suponha que queira-se rescrever uma expressão com números naturais utilizando a propriedade de comutatividade: o lema para isto é dado por \lstinline[language = coq]!addnC! e pode ser notado como o lema que se deseja utilizar por sua definição:
\begin{lstlisting}[language=coq]
        Lemma addnC : commutative addn.
\end{lstlisting}
Agora, supondo que se tenha a mesma situação envolvendo números inteiros. É provável que não seja tão simples para o mesmo usuário encontrar o lema desejado, pois nesse caso, apesar da existência do lema \lstinline[language = coq]!addzC! com definição:
\begin{lstlisting}[language=coq]
        Lemma addzC : commutative addz.
\end{lstlisting}
pelo fato da notação \lstinline[language = coq]!+! não ser definida para a operação \lstinline[language = coq]!addz! (operação de soma entre inteiros) mas sim para determinadas operações binárias de estruturas semelhantes ao \textit{record} apresentado na Subseção \ref{sub:grupos}, tal lema não irá servir (exceto caso o usuário esteja utilizando a função \lstinline[language = coq]!addz! e não a notação \lstinline[language = coq]!+!).

Sendo assim, para realizar a manipulação desejada, deve-se utilizar o lema \lstinline[language = coq]!addrC!, qual possui a seguinte definição: 
\begin{lstlisting}[language=coq]
        forall s : nmodType, commutative +%R
\end{lstlisting}
Note que o lema é definido pra uma estrutura \lstinline[language = coq]!nmodType!; estruturas como essa são muito comuns nos códigos da Mathematical Components, e, conforme apresentado no guia de contribuições da biblioteca\footnote{Disponível em: https://github.com/math-comp/math-comp/blob/master/CONTRIBUTING.md}, pode-se verificar, utilizando a linguagem HB \cite{cohen_et_al:LIPIcs.FSCD.2020.34} para hierarquia de estruturas algébricas, os lemas que caracterizam \lstinline[language = coq]!nmodType!, usando o seguinte comando: 
\begin{lstlisting}[language=coq]
        HB.about nmodType.
\end{lstlisting}
que irá apresentar uma mensagem contendo, em parte dela, o seguinte conteúdo:
\begin{lstlisting}[language=coq-error]
        HB: nmodType is a structure (from "./ssralg.v", line 589)
        HB: nmodType characterizing operations and axioms are:
        - add0r
        - addrC
        - addrA
        - add
        - zero
\end{lstlisting}
Verificando as definições dos nomes apresentados nesta mensagem podemos notar que tal estrutura possui uma operação (\lstinline[language = coq]!add!), um elemento neutro à esquerda (\lstinline[language = coq]!zero! e \lstinline[language = coq]!add0r!) e as propriedades de comutatividade e associatividade para tal operação (\lstinline[language = coq]!addrC! e \lstinline[language = coq]!addrA!).
Usando o mesmo comando (\lstinline[language = coq]!HB.about!) sobre o tipo \lstinline[language = coq]!int!, tem-se como resultado na mensagem apresentada as estruturas com as quais o tipo está ``equipado'', e dentre estas tem-se \lstinline[language = coq]!GRing.Nmodule! (para qual \lstinline[language=coq]!nmodType! é um sinônimo). 

Tal organização presente na biblioteca, ao ser conhecida pelo usuário, torna mais fácil e organizada a manipulação de diferentes tipos, e é portanto uma informação importante para leitores deste trabalho que desejam futuramente fazer uso da mesma biblioteca. 

\textcolor{red}{ Ainda da pra mexer nessa subseção, pra citar mais referências apesar de eu não ter precisado tanto por que as informações são meio obvias após algum tempo de uso da biblioteca, acho q é interessante citar pra dar mais segurança ao leitor (e a mim mesmo também)}

\textcolor{darkgreen}{\textbf{IDEIA}: jogar essa seção para o Capítulo 2.}
% conforme apresentado em \cite{2023multipleinheritancehazardsdependentlytypedalgebraic}, são utilizadas para 

\section{Implementações Externas de Maior Relevância}
Dentre os teoremas e lemas utilizados neste trabalho (dos quais a grande maioria são lemas simples da biblioteca Mathematical Components), existe um lema e um teorema que merecem destaque devido a complexidade para a prova dos mesmos, haja vista a dificuldade em se fazer uma formalização com base na ideia da prova manual destes (ambas apresentadas neste trabalho).

O primeiro lema a ser mencionado trata do caso \ref{item:caso3wilson} do Teorema \ref{teorema : wilson} e tem na biblioteca o seguinte enunciado:
\begin{lstlisting}[language=coq]
        Theorem Wilson p : p > 1 -> prime p = (p %| ((p.-1)`!).+1).
\end{lstlisting}
É importante notar, que, a igualdade entre as proposições booleanas \lstinline[language=coq]!prime p! e \lstinline[language=coq]!p %| ((p.-1)`!).+1! significa uma bi-implicação caso estas proposições não fossem booleanas. Além disso, vale aqui lembrar da definição de equivalência em módulo $p$, e que portanto:
\begin{equation}
        p \mid (p-1)! + 1 \Longleftrightarrow (p-1)! \equiv -1 \pmod{p} 
\end{equation}

Quanto ao segundo item a ser mencionado, este trata do Lema \ref{lema : modp-1fat} e foi provado por Laurent Théry durante o período de realiazação deste trabalho. A prova deste está disponível em: \hyperlink{https://github.com/thery/mathcomp-extra/blob/master/euler.v}{https://github.com/thery/mathcomp-extra/blob/master/euler.v} e tem a seguinte declaração:
\begin{lstlisting}[language=coq]
        Lemma fact_sqr_exp a p :
        prime p -> ~~ (p %| a) -> ~~ res_quad p a -> (p.-1`!) = a ^ p.-1./2 %[mod p].
\end{lstlisting}
onde \lstinline[language=coq]!res_quad! tem a seguinte definição:
\begin{lstlisting}[language=coq]
        Definition res_quad p a := has (fun i => i * i == a %[mod p]) (iota 0 p).
\end{lstlisting}
em que, a função \lstinline[language=coq]!has! recebe um predicado booleano e uma lista, e então retorna \lstinline[language=coq]!true!
se há algum elemento da lista que satisfaz o predicado e \lstinline[language=coq]!false! caso contrário. Já a função \lstinline[language=coq]!iota! recebe dois números naturais $m$ e $n$ e retorna uma lista crescente de todos os naturais de $m$ até $n-1+m$. Sendo assim, a função \lstinline[language=coq]!res_quad! é um método exaustivo para verificar se há um valor $r$ tal que $r^{2} \equiv a \pmod{p}$.

As dificuldades relacionadas as provas destas declarações em \textit{Coq}, se baseando nas ideias de provais manuais apresentadas neste trabalho, deve-se ao fato de que tais ideias sugerem a reorganização de todos os termos de produtórios com tamanho arbitrário. E tais provas além de dificeís não podem ser evitadas ao se buscar a implementação de \textit{símbolo de Legendre} em \textit{Coq} dado que tratam de conteúdos diretamente conectados (principalmente ao se considerar o Teorema \ref{teorema:criteriodeeuler}).

Devido a essa dificuldade, que pode vir a aparecer em diversas situações onde tem-se uma ideia de prova semelhante a ser formalizada, é de interesse se ter conhecimento de como as provas do Teorema \ref{teorema : wilson} e do Lema \ref{lema : modp-1fat} foram feitas em \textit{Coq}. Para satisfazer tal necessidade será aqui explicada em detalhe (com excessão da maioria dos \textit{subgoals} e outras partes triviais) o conteúdo da prova do Lema \ref{lema : modp-1fat} realizada por Laurent Théry. O código da prova pode-ser divido nas seguintes etapas:

\begin{enumerate}[label=\textbf{\roman*.}]

        % Parte 01:

        \item Inicialmente tem-se o seguinte \textit{goal}:
        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
prime p -> ~~ (p %| a) -> ~~ res_quad p a -> (p.-1`!) = a ^ p.-1./2 %[mod p]
        \end{lstlisting}
        Introduz-se então todas as hipóteses e se reescreve $(p-1)!$:
        \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1]
move=> pP pNDa aR.
have -> : p.-1`! = \prod_(i in 'F_p | i != 0%R) i.
        (* ... prova do subgoal... *)
        \end{lstlisting}
        Explicando os comandos feitos em linhas específicas têm-se:
        \begin{enumerate}
                \item[\textbf{(1)}] introdução dos precedentes do \textit{goal} para hipóteses com os nomes \lstinline[language=coq]|pP|, \lstinline[language=coq]|pNDa| e \lstinline[language=coq]|aR| respectivamente;
                
                \item[\textbf{(2)}] reescrita de $(p-1)!$ como $\prod_{i \in (\mathbb{F}_p - \{0\})} i$ (o que por sua vez abre um subgoal);
                
                % \item[\textbf{(3)}] resolução do \textit{subgoal} aberto na linha 2.
        \end{enumerate}

        % Parte 02:

        \item Tendo agora o seguinte \textit{goal}:
        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(i in 'F_p | i != 0%R) i  = a ^ p.-1./2  %[mod p]
        \end{lstlisting}
        faz-se então uma série de declarações de variáveis e funções junto à introdução de novas hipóteses:
        \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1]
pose a' : 'F_p := inZp a.
have a'E : a' = a %% p :> nat
        by rewrite /= Fp_cast.
have a'_neq0 : a' != 0%R.
        (*... prova do subgoal...*)
rewrite -modnXm -a'E.
pose f (i : 'F_p) : 'F_p := (a' / i)%R. 
have f_eq0 : f 0%R = 0%R by rewrite /f GRing.invr0 GRing.mulr0. 
have fM (i : 'F_p) : i != ord0 -> (f i * i = a')%R. 
        (*... prova do subgoal...*)
have fI (i : 'F_p) : f (f i) = i.
        (*... prova do subgoal...*)
have fI_neq0 (i : 'F_p) : i != 0%R -> f i != i.
        (*... prova do subgoal...*)
have fB : {on [pred i |  i != ord0],  bijective f}.
        (*... prova do subgoal...*)
pose can (i : 'F_p) :=  if i < (f i) then i else f i.
        \end{lstlisting}
        Explicando os comandos feitos em linhas específicas tem-se:
        \begin{enumerate}
                \item[\textbf{(1)}] declaração da variável $a' \in \mathbb{F}_p$ que por sua vez depende do valor de $a$;
                
                \item[\textbf{(2)}] introdução da hipótese \lstinline[language=coq]|a'E| de que $a' = a \bmod{p}$; 
                
                \item[\textbf{(4)}] introdução da hipótese \lstinline[language=coq]|a'_neq0| de que $a' \neq 0$;
                
                \item[\textbf{(6)}] reescrita (no \textit{goal}) de $a^{\frac{p-1}{2}}$ como $(a')^{\frac{p-1}{2}}$;
                
                \item[\textbf{(7)}] declaração de uma função $f : \mathbb{F}_p \rightarrow \mathbb{F}_p$ tal que $f(i) = (a') \cdot i^{-1}$ (onde $i^{-1}$ é o inverso de $i$ em $\mathbb{F}_p$ e a notação \lstinline[language=coq]|"x / y"| é definida como \lstinline[language=coq]|x * y^-1|);
                
                \item[\textbf{(8)}] introducão (e prova na mesma linha a partir do comando \lstinline[language=coq]|by|) da hipótese \lstinline[language=coq]|f_eq0| de que $f(0) = 0$;
                
                \item[\textbf{(9)}] introducão da hipótese \lstinline[language=coq]|fM| de que $\forall i \in \mathbb{F}_p, (i \neq 0 \rightarrow f(i) \cdot i = a')$;
                
                \item[\textbf{(11)}] introducão da hipótese \lstinline[language=coq]|fI| de que $\forall i \in \mathbb{F}_p, f(f(i)) = i$, isto é, $f$ é involutiva;
                
                \item[\textbf{(13)}] introducão da hipótese \lstinline[language=coq]|fI_neq0| de que $\forall i \in \mathbb{F}_p, (i \neq 0 \rightarrow f(i) \neq i)$;
                
                \item[\textbf{(15)}] introducão da hipótese \lstinline[language=coq]|fB| de existe uma função $f : (\mathbb{F}_p - \{0\}) \rightarrow (\mathbb{F}_p - \{0\})$ que é bijetora (o que é óbvio já que a função $f$ declarada anteriormente é involutiva).
                
                \item[\textbf{(17)}] declaração de uma função $can : \mathbb{F}_p \rightarrow \mathbb{F}_p$ tal que $can(i)$ retorna o valor mínimo entre $i$ e $f(i)$.
        \end{enumerate}

        \item Tendo agora o seguinte \textit{goal}:
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(i in 'F_p | i != 0%R) i  = a' ^ p.-1./2  %[mod p]
                \end{lstlisting}
        faz-se a seguinte reescrita:
                \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1]
have -> : \prod_(i in 'F_p | i != 0%R) i =
                \prod_(j in 'F_p | (j < f j))
                        \prod_(i in 'F_p | (i != 0%R) && (can i == j)) i.
        (*... prova do subgoal...*)
                \end{lstlisting}
        Explicando os comandos feitos em linhas específicas têm-se:
        \begin{enumerate}

                \item[\textbf{(1)}] substituição (no \textit{goal}) de $\prod_{i \in (\mathbb{F}_p - \{0\})} i$ por:
                        \begin{equation*}
                        \prod_{j \in \mathbb{F}_p \mid j < f(j)} \left( \prod_{i \in (\mathbb{F}_p - \{0\}) \mid can(i)= j} i \right)
                        \end{equation*}

                \item[\textbf{(4)}] código da prova do \textit{subgoal} gerado na linha 1 - este código não será apresentado aqui, no entanto, pode-se dizer que tal subprova se baseia na utilização do lema \lstinline[language=coq]|partition_big|, que tem a seguinte declaração:
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma partition_big {R : Type} {idx : R} {op : Monoid.com_law idx} 
{I : Type} {s : seq I} {J : finType} {P : pred I} (p : I -> J) (Q : pred J) 
{F : I -> R} :
(\forall i : I, P i -> Q (p i)) ->
        \big[op/idx]_(i <- s | P i) F i =
        \big[op/idx]_(j | Q j) \big[op/idx]_(i <- s | P i && (p i == j)) F i
                        \end{lstlisting}
                onde \lstinline[language=coq]|\big[op/idx]| é parte comum de uma série de notações para uso da função \lstinline[language=coq]|bigop|, que, conforme apresentado em \cite{assia_mahboubi_2022_7118596}, pode ser definido (apesar de não possuir exatamente esta implementação na biblioteca) como:
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Definition bigop R I idx op r (P : pred I) (F : I -> R) : R :=
        foldr (fun i x => if P i then op (F i) x else x) idx r.
                        \end{lstlisting}
                e dentre as notações para o uso desta função tem-se:
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Notation "\big [ op / idx ]_ ( i <- r | P ) F" :=
        (bigop idx op r (fun i => P%B) (fun i => F)) : big_scope.
                        \end{lstlisting}
                Assim , pode-se perceber que a notação de um produtório é um açucar sintático para a uso do operador \lstinline[language=coq]|bigop| com o argumento \lstinline[language=coq]|op| sendo a operação de multiplicação e o argumento \lstinline[language=coq]|idx| sendo 1. 
                
                Nesta subprova usa-se então o lema \lstinline[language=coq]|partition_big| com \lstinline[language=coq]|P i| sendo a condição $(i \neq 0)$, \lstinline[language=coq]|p| sendo a função $can$ e \lstinline[language=coq]|Q j| sendo a condição $(j < f(j))$. Após o uso de tal lema é então necessário provar mais um subgoal (que não é printado exatamente da seguinte forma mas é equivalente a tal): 
                % devido ao lema \lstinline[language=coq]|Fp_cast|):
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\forall i : 'F_p, i != 0%R -> can i < (a %% p * ((can i)^-1)%R) %% p
                \end{lstlisting}
                
        \end{enumerate}

        \item Após a resolução dos \textit{subgoals} gerados anteriormente, o \textit{goal} atual se torna o seguinte:
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(j in 'F_p | j < f j) 
        \prod_(i in 'F_p | (i != 0%R) && (can i == j)) i
                                        = a' ^ p.-1./2  %[mod p]
                \end{lstlisting}
        usa-se a seguinte tática:
                \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1]
apply: etrans (_ : \prod_(j in 'F_p | j < f j) (j * f j) = _ %[mod p]).
        (*... prova do subgoal 1...*)
        (*... prova do subgoal 2...*)
                \end{lstlisting}
        Esta tática então aplicada na linha 1 utiliza da transitividade da igualdade por meio do lema \lstinline[language=coq]|etrans| junto a um argumento que permite que o \textit{Coq} infira o termo médio desta transitividade. Este argumento é uma prova de igualdade, qual por não existir nas hipóteses irá gerar 2 \textit{subgoals} no lugar do \textit{goal} atual.

        Sendo assim o primeiro \textit{subgoal} a ser provado é:
                \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(j in 'F_p | j < f j) \prod_(i in 'F_p | (i != 0%R) && (can i == j)) i
        = \prod_(j in 'F_p | j < f j) (j * f j)  %[mod p]
                \end{lstlisting}
        para qual são usadas as seguintes táticas:
                \begin{lstlisting}[language=coq,frame=single, numbers=left,stepnumber=1,tabsize=1, escapechar=\$]
congr (_ %% _).                         $\label{line:1-item4-2}$
apply: eq_bigr => j /andP[jF jLfj].     $\label{line:2-item4-2}$
rewrite (bigD1 j); last first.          $\label{line:3-item4-2}$
        (*... prova do subgoal...*)
rewrite [LHS]/=.                        $\label{line:5-item4-2}$
rewrite (bigD1 (f j)); last first.      $\label{line:6-item4-2}$
        (*... prova do subgoal...*)
rewrite big1 /= ?muln1 // => i.         $\label{line:8-item4-2}$
                \end{lstlisting}
        Explicando os comandos feitos em linhas específicas têm-se:
        \begin{enumerate}
                
                \item[\textbf{(\ref{line:1-item4-2})}] retirada da aplicação de $\bmod \; p$ em ambos os lados da equação;
                
                \item[\textbf{(\ref{line:2-item4-2})}]aplicação do lema \lstinline[language=coq]|eq_bigr| junto à eliminação do $\forall$ e introdução da hipótese gerada por tal aplicação; é interessante ao leitor não acostumado com as táticas da linguagem SSReflect notar que, sabendo que o lema \lstinline[language=coq]|eq_bigr| tem o seguinte enunciado:
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma eq_bigr r (P : pred I) F1 F2 : (forall i, P i -> F1 i = F2 i) ->
        \big[op/idx]_(i <- r | P i) F1 i = \big[op/idx]_(i <- r | P i) F2 i.
                        \end{lstlisting}
                após a aplicação do lema e eliminação do $\forall$, o \textit{goal} se torna:
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
(j  \in 'F_p) && (j < f j) -> 
        \prod_(i in 'F_p | (i != 0%R) && (can i == j)) i = j * f j
                        \end{lstlisting}
                mas nesse caso também é feita a introdução da hipótese com \lstinline[language=coq]|/andP[jF jLfj]|, que torna, em tal hipótese, a expressão com operador \lstinline[language=coq]|&&| (conjunção booleana) em uma expressão equivalente com \lstinline[language=coq]|/\| (conjunção proposicional) que é então separada nas hipóteses \lstinline[language=coq]|jF| e \lstinline[language=coq]|jLfj|.

                Pode-se notar portanto que a partir da aplicação do lema \lstinline[language=coq]|eq_bigr| o \textit{goal} consiste em provar que o termo geral dos produtórios é igual.

                \item[\textbf{(3)}] reescrita por meio do lema \lstinline[language=coq]|bigD1| com o \textit{goal} sendo (devido as alterações feitas nas linhas anteriores):
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
\prod_(i in 'F_p | (i != 0%R) && (can i == j)) i = j * f j
                        \end{lstlisting}
                Este lema basicamente retira um elemento de dentro da aplicação do operador \lstinline[language=coq]|bigop| (nesse caso o elemento \lstinline[language=coq]|j| pois foi este o argumento passado ao lema), no entanto deve-se demonstrar que tal elemento realmente ocorre em alguma das iterações, por isto é então gerado um \textit{subgoal}. Esse \textit{subgoal} normalmente deveria ser resolvido após a resolução do \textit{goal} principal, mas devido ao uso de \lstinline[language=coq]|last first| tal \textit{subgoal} deve ser resolvido antes do \textit{goal} principal.
                
                \item[\textbf{(5)}] comando adicionado apenas para tornar o \textit{goal} mais legível (não é algo que estava na prova original feita por Laurent), e nesse caso, após a execução dos comandos da linha 3 e deste comando, o \textit{goal} se torna:
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
j * \prod_(i < (Zp_trunc (pdiv p)).+2 | (i != 0%R) && (can i == j) && (i != j))  i = j * f j
                        \end{lstlisting}
                em que \lstinline[language=coq]|(Zp_trunc (pdiv p)).+2| é igual a \lstinline[language=coq]|p|, o que é apresentado pelo lema \lstinline[language=coq]|Fp_cast|.

                \item[\textbf{(6)}] reescrita análoga a feita an linha 3, porém retirando o elemento \lstinline[language=coq]|f j| do produtório, de modo que o \textit{goal} se torne então:
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
j * ssrnat_muln__canonical__SemiGroup_ComLaw (f j)
        (\big[ssrnat_muln__canonical__SemiGroup_ComLaw/1]_(i | (i != 0%R) 
                && (can i == j) && (i != j) && (i != f j)) i) 
                        = j * f j
                        \end{lstlisting}
                onde \lstinline[language=coq]|ssrnat_muln__canonical__SemiGroup_ComLaw| é basicamente a operação de multiplicação.

                \item[\textbf{(8)}] reescrita do produtório ainda presente no \textit{goal} como 1 (elemento neutro) por meio do lema \lstinline[language=coq]|big1|, que por sua vez tem o seguinte enunciado:
                        \begin{lstlisting}[language=coq,frame=single,tabsize=1]
Lemma big1 {R : Type} {idx : R} {op : Monoid.law idx} I r (P : pred I) F :
        (forall i : I, P i -> F i = idx) -> 
                \big[op/idx]_(i <- r | P i) F i = idx.
                        \end{lstlisting}
                seguindo de computação (dada por \lstinline[language=coq]|/=|), reescrita da multiplicação por 1 (simplificação), resolução do goal por meio de \lstinline[language=coq]|//| (semelhante ao comando \lstinline[language=coq]|simplify|) e eliminação do $\forall$ (com "\lstinline[language=coq]|=> i|") do \textit{subgoal} aberto pelo uso do lema \lstinline[language=coq]|big1|.

                Este \textit{subgoal} aberto consiste em provar que as condições do produtório nunca serão atendidas.
        \end{enumerate}

\end{enumerate}

% Alguns lemas, teoremas e definições que já haviam sido implementados na biblioteca, junto a um que foi implementado durante o período de realização deste trabalho (e portanto possívelmente, na data de publicação deste trabalho, ainda não está incluído na biblioteca) foram de grande importância para alcance dos objetivos estabelecidos. Sendo assim, é de interesse que sejam aqui mencionados.

\section{Formalização do Símbolo de Legendre}

Seguindo a ideia utilizada (e recomendada) por Laurent Théry, em se utilizar uma função exaustiva para verificar se um determinado número é um resíduo quadrático módulo $p$ (em que $p$ é um número primo), e portanto, ter-se uma função que é pelo menos computável (apesar de sua ineficácia), fez-se neste trabalho a seguinte definição para o \textit{símbolo de Legendre}:
\begin{lstlisting}[language=coq]
        Definition legendre_symb {p : int} (pL2 : (2 < p)%R) (pP : primez.primez p) 
        (a : int) :=
        if (p %| a)%Z then 0%Z
        else if has (fun i => ((i * i)%:Z  == a %[mod p])%Z) (iota 0 `|p|)
        then 1%Z
        else (-1)%Z.
\end{lstlisting}
Com esta definição, o \textit{símbolo de Legendre} é portanto uma função que recebe um número inteiro $p$, uma prova de que $2 < p$, uma prova de que $p$ é um número primo e por último um número inteiro $a$. Note que os argumentos que constituem provas podem ser gerados automaticamente pelo usuário dado que as funções \lstinline[language=coq]!<! e \lstinline[language=coq]!primez! são computáveis. Como exemplo de uso da função tem-se portanto:
\begin{lstlisting}[language=coq]
        Compute (legendre_symb (_ : 2 < 7)%R (_ : primez.primez 7) 2).
\end{lstlisting}
que neste caso irá retornar $1$.

Havendo a definição de \textit{símbolo de Legendre} resta então provar as suas principais propriedades, que podem vir a ser úteis em trabalhos futuros. Se baseando em \cite{book:2399854}, as principais propriedades do \textit{símbolo de Legendre}, considerando um número primo $p > 2$, são, para todo $a, b \in \mathbb{Z}$:
\begin{enumerate}
        \item $a \equiv b \pmod{p} \rightarrow \left(\frac{a}{p}\right) = \left(\frac{b}{p}\right)$, cuja declaração dada em \textit{Coq} é:
        \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
        \begin{lstlisting}[language=coq]
Lemma legendre_symbE (p a b : int) (pL2 : (2 < p)%R) 
(pP : primez.primez p):
(a == b %[mod p])%Z -> 
        ((legendre_symb pL2 pP a) == (legendre_symb pL2 pP b)).
        \end{lstlisting}
        \end{tcolorbox}
        
        \item $p \nmid a \rightarrow \left(\frac{a^2}{p}\right)$, cuja declaração dada em \textit{Coq} é:
        \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
        \begin{lstlisting}[language=coq]
Lemma legendre_symb_Ndvd (p a b : int) (pL2 : (2 < p)%R) 
(pP : primez.primez p):
~~(p %| a)%Z -> (legendre_symb pL2 pP (a^2)) == 1.
        \end{lstlisting}
        \end{tcolorbox}
        
        \item $\left(\frac{-1}{p}\right) = (-1)^{\frac{p - 1}{2}} = 1 \leftrightarrow p \equiv 1 \pmod{p}$, cuja declaração dada em \textit{Coq} é:
        \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
        \begin{lstlisting}[language=coq]
Lemma legendre_symb_Neg1 (p : int) (pL2 : (2 < p)%R) 
(pP : primez.primez p):
((legendre_symb pL2 pP (-1)) == 1) = (p == 1 %[mod 4])%Z.
        \end{lstlisting}
        \end{tcolorbox}
        
        % \item $\left(\frac{-1}{p}\right) = (-1)^{\frac{p - 1}{2}} = -1 \leftrightarrow p \equiv 3 \pmod{p}$ 
        
        \item $\left(\frac{a \cdot b}{p}\right) = \left(\frac{a}{p}\right) \cdot \left(\frac{b}{p}\right)$, cuja declaração dada em \textit{Coq} é:
        \begin{tcolorbox}[colback=yellow!5!white,colframe=yellow!75!black,width=14cm]
        \begin{lstlisting}[language=coq]
Lemma legendre_symb_Neg1 (p : int) (pL2 : (2 < p)%R) 
(pP : primez.primez p):
((legendre_symb pL2 pP (-1)) == 1) = (p == 1 %[mod 4])%Z.
        \end{lstlisting}
        \end{tcolorbox}
\end{enumerate}

A formalização (isto é, prova) de todos estes lemas está disponível no seguinte \hyperlink{https://github.com/bruniculos08/TCC2005/blob/main/Código - Parte 02/InversoMultiplicativo.v}{repositório}.

